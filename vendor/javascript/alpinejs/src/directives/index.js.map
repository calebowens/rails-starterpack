// alpinejs@3.13.5/src/directives/index.js.map downloaded from https://ga.jspm.io/npm:alpinejs@3.13.5/src/directives/index.js.map

{"version":3,"file":"index.js","sources":["../../src/directives/x-modelable.js","../../src/directives/x-teleport.js","../../src/directives/x-ignore.js","../../src/directives/x-effect.js","../../src/directives/x-model.js","../../src/directives/x-cloak.js","../../src/directives/x-init.js","../../src/directives/x-text.js","../../src/directives/x-html.js","../../src/directives/x-bind.js","../../src/directives/x-data.js","../../src/directives/x-show.js","../../src/directives/x-for.js","../../src/directives/x-ref.js","../../src/directives/x-if.js","../../src/directives/x-id.js","../../src/directives/x-on.js","../../src/directives/index.js"],"sourcesContent":["import { directive } from '../directives'\nimport { entangle } from '../entangle';\n\ndirective('modelable', (el, { expression }, { effect, evaluateLater, cleanup }) => {\n    let func = evaluateLater(expression)\n    let innerGet = () => { let result; func(i => result = i); return result; }\n    let evaluateInnerSet = evaluateLater(`${expression} = __placeholder`)\n    let innerSet = val => evaluateInnerSet(() => {}, { scope: { '__placeholder': val }})\n\n    let initialValue = innerGet()\n\n    innerSet(initialValue)\n\n    queueMicrotask(() => {\n        if (! el._x_model) return\n\n        // Remove native event listeners as these are now bound with x-modelable.\n        // The reason for this is that it's often useful to wrap <input> elements\n        // in x-modelable/model, but the input events from the native input\n        // override any functionality added by x-modelable causing confusion.\n        el._x_removeModelListeners['default']()\n\n        let outerGet = el._x_model.get\n        let outerSet = el._x_model.set\n\n        let releaseEntanglement = entangle(\n            {\n                get() { return outerGet() },\n                set(value) { outerSet(value) },\n            },\n            {\n                get() { return innerGet() },\n                set(value) { innerSet(value) },\n            },\n        )\n\n        cleanup(releaseEntanglement)\n    })\n})\n","import { onlyDuringClone, skipDuringClone } from \"../clone\"\nimport { directive } from \"../directives\"\nimport { addInitSelector, initTree } from \"../lifecycle\"\nimport { mutateDom } from \"../mutation\"\nimport { addScopeToNode } from \"../scope\"\nimport { warn } from \"../utils/warn\"\n\ndirective('teleport', (el, { modifiers, expression }, { cleanup }) => {\n    if (el.tagName.toLowerCase() !== 'template') warn('x-teleport can only be used on a <template> tag', el)\n\n    let target = getTarget(expression)\n\n    let clone = el.content.cloneNode(true).firstElementChild\n\n    // Add reference to element on <template x-teleport, and visa versa.\n    el._x_teleport = clone\n    clone._x_teleportBack = el\n\n    // Add the key to the DOM so they can be more easily searched for and linked up...\n    el.setAttribute('data-teleport-template', true)\n    clone.setAttribute('data-teleport-target', true)\n\n    // Forward event listeners:\n    if (el._x_forwardEvents) {\n        el._x_forwardEvents.forEach(eventName => {\n            clone.addEventListener(eventName, e => {\n                e.stopPropagation()\n\n                el.dispatchEvent(new e.constructor(e.type, e))\n            })\n        })\n    }\n\n    addScopeToNode(clone, {}, el)\n\n    let placeInDom = (clone, target, modifiers) => {\n        if (modifiers.includes('prepend')) {\n            // insert element before the target\n            target.parentNode.insertBefore(clone, target)\n        } else if (modifiers.includes('append')) {\n            // insert element after the target\n            target.parentNode.insertBefore(clone, target.nextSibling)\n        } else {\n            // origin\n            target.appendChild(clone)\n        }\n    }\n\n    mutateDom(() => {\n        placeInDom(clone, target, modifiers)\n\n        initTree(clone)\n\n        clone._x_ignore = true\n    })\n\n    el._x_teleportPutBack = () => {\n        let target = getTarget(expression)\n\n        mutateDom(() => {\n            placeInDom(el._x_teleport, target, modifiers)\n        })\n    }\n\n    cleanup(() => clone.remove())\n})\n\nlet teleportContainerDuringClone = document.createElement('div')\n\nfunction getTarget(expression) {\n    let target = skipDuringClone(() => {\n        return document.querySelector(expression)\n    }, () => {\n        return teleportContainerDuringClone\n    })()\n\n    if (! target) warn(`Cannot find x-teleport element for selector: \"${expression}\"`)\n\n    return target\n}\n","import { directive } from \"../directives\"\n\nlet handler = () => {}\n\nhandler.inline = (el, { modifiers }, { cleanup }) => {\n    modifiers.includes('self')\n        ? el._x_ignoreSelf = true\n        : el._x_ignore = true\n\n    cleanup(() => {\n        modifiers.includes('self')\n            ? delete el._x_ignoreSelf\n            : delete el._x_ignore\n    })\n}\n\ndirective('ignore', handler)\n","import { skipDuringClone } from '../clone'\nimport { directive } from '../directives'\nimport { evaluate, evaluateLater } from '../evaluator'\n\ndirective('effect', skipDuringClone((el, { expression }, { effect }) => {\n    effect(evaluateLater(el, expression))\n}))\n","import { evaluateLater } from '../evaluator'\nimport { directive } from '../directives'\nimport { mutateDom } from '../mutation'\nimport { nextTick } from '../nextTick'\nimport bind, { safeParseBoolean } from '../utils/bind'\nimport on from '../utils/on'\nimport { warn } from '../utils/warn'\nimport { isCloning } from '../clone'\n\ndirective('model', (el, { modifiers, expression }, { effect, cleanup }) => {\n    let scopeTarget = el\n\n    if (modifiers.includes('parent')) {\n        scopeTarget = el.parentNode\n    }\n\n    let evaluateGet = evaluateLater(scopeTarget, expression)\n    let evaluateSet\n\n    if (typeof expression === 'string') {\n        evaluateSet = evaluateLater(scopeTarget, `${expression} = __placeholder`)\n    } else if (typeof expression === 'function' && typeof expression() === 'string') {\n        evaluateSet = evaluateLater(scopeTarget, `${expression()} = __placeholder`)\n    } else {\n        evaluateSet = () => {}\n    }\n\n    let getValue = () => {\n        let result\n\n        evaluateGet(value => result = value)\n\n        return isGetterSetter(result) ? result.get() : result\n    }\n\n    let setValue = value => {\n        let result\n\n        evaluateGet(value => result = value)\n\n        if (isGetterSetter(result)) {\n            result.set(value)\n        } else {\n            evaluateSet(() => {}, {\n                scope: { '__placeholder': value }\n            })\n        }\n    }\n\n    if (typeof expression === 'string' && el.type === 'radio') {\n        // Radio buttons only work properly when they share a name attribute.\n        // People might assume we take care of that for them, because\n        // they already set a shared \"x-model\" attribute.\n        mutateDom(() => {\n            if (! el.hasAttribute('name')) el.setAttribute('name', expression)\n        })\n    }\n\n    // If the element we are binding to is a select, a radio, or checkbox\n    // we'll listen for the change event instead of the \"input\" event.\n    var event = (el.tagName.toLowerCase() === 'select')\n        || ['checkbox', 'radio'].includes(el.type)\n        || modifiers.includes('lazy')\n            ? 'change' : 'input'\n\n    // We only want to register the event listener when we're not cloning, since the\n    // mutation observer handles initializing the x-model directive already when\n    // the element is inserted into the DOM. Otherwise we register it twice.\n    let removeListener = isCloning ? () => {} : on(el, event, modifiers, (e) => {\n        setValue(getInputValue(el, modifiers, e, getValue()))\n    })\n\n    if (modifiers.includes('fill'))\n        if ([undefined, null, ''].includes(getValue())\n            || (el.type === 'checkbox' && Array.isArray(getValue()))) {\n            el.dispatchEvent(new Event(event, {}));\n    }\n    // Register the listener removal callback on the element, so that\n    // in addition to the cleanup function, x-modelable may call it.\n    // Also, make this a keyed object if we decide to reintroduce\n    // \"named modelables\" some time in a future Alpine version.\n    if (! el._x_removeModelListeners) el._x_removeModelListeners = {}\n    el._x_removeModelListeners['default'] = removeListener\n\n    cleanup(() => el._x_removeModelListeners['default']())\n\n    // If the input/select/textarea element is linked to a form\n    // we listen for the reset event on the parent form (the event\n    // does not trigger on the single inputs) and update\n    // on nextTick so the page doesn't end up out of sync\n    if (el.form) {\n        let removeResetListener = on(el.form, 'reset', [], (e) => {\n            nextTick(() => el._x_model && el._x_model.set(el.value))\n        })\n        cleanup(() => removeResetListener())\n    }\n\n    // Allow programmatic overriding of x-model.\n    el._x_model = {\n        get() {\n            return getValue()\n        },\n        set(value) {\n            setValue(value)\n        },\n    }\n\n    el._x_forceModelUpdate = (value) => {\n        // If nested model key is undefined, set the default value to empty string.\n        if (value === undefined && typeof expression === 'string' && expression.match(/\\./)) value = ''\n\n        // @todo: This is nasty\n        window.fromModel = true\n        mutateDom(() => bind(el, 'value', value))\n        delete window.fromModel\n    }\n\n    effect(() => {\n        // We need to make sure we're always \"getting\" the value up front,\n        // so that we don't run into a situation where because of the early\n        // the reactive value isn't gotten and therefore disables future reactions.\n        let value = getValue()\n\n        // Don't modify the value of the input if it's focused.\n        if (modifiers.includes('unintrusive') && document.activeElement.isSameNode(el)) return\n\n        el._x_forceModelUpdate(value)\n    })\n})\n\nfunction getInputValue(el, modifiers, event, currentValue) {\n    return mutateDom(() => {\n        // Check for event.detail due to an issue where IE11 handles other events as a CustomEvent.\n        // Safari autofill triggers event as CustomEvent and assigns value to target\n        // so we return event.target.value instead of event.detail\n        if (event instanceof CustomEvent && event.detail !== undefined)\n            return event.detail !== null && event.detail !== undefined ? event.detail : event.target.value\n        else if (el.type === 'checkbox') {\n            // If the data we are binding to is an array, toggle its value inside the array.\n            if (Array.isArray(currentValue)) {\n                let newValue = null;\n\n                if (modifiers.includes('number')) {\n                    newValue = safeParseNumber(event.target.value)\n                } else if (modifiers.includes('boolean')) {\n                    newValue = safeParseBoolean(event.target.value)\n                } else {\n                    newValue = event.target.value\n                }\n\n                return event.target.checked ? currentValue.concat([newValue]) : currentValue.filter(el => ! checkedAttrLooseCompare(el, newValue))\n            } else {\n                return event.target.checked\n            }\n        } else if (el.tagName.toLowerCase() === 'select' && el.multiple) {\n            if (modifiers.includes('number')) {\n                return Array.from(event.target.selectedOptions).map(option => {\n                    let rawValue = option.value || option.text\n                    return safeParseNumber(rawValue)\n                })\n            } else if (modifiers.includes('boolean')) {\n                return Array.from(event.target.selectedOptions).map(option => {\n                    let rawValue = option.value || option.text\n                    return safeParseBoolean(rawValue)\n                })\n            }\n\n            return Array.from(event.target.selectedOptions).map(option => {\n                return option.value || option.text\n            })\n        } else {\n            if (modifiers.includes('number')) {\n                return safeParseNumber(event.target.value)\n            } else if (modifiers.includes('boolean')) {\n                return safeParseBoolean(event.target.value)\n            }\n\n            return modifiers.includes('trim') ? event.target.value.trim() : event.target.value\n        }\n    })\n}\n\nfunction safeParseNumber(rawValue) {\n    let number = rawValue ? parseFloat(rawValue) : null\n\n    return isNumeric(number) ? number : rawValue\n}\n\nfunction checkedAttrLooseCompare(valueA, valueB) {\n    return valueA == valueB\n}\n\nfunction isNumeric(subject){\n    return ! Array.isArray(subject) && ! isNaN(subject)\n}\n\nfunction isGetterSetter(value) {\n    return value !== null && typeof value === 'object' && typeof value.get === 'function' && typeof value.set === 'function'\n}\n","import { directive, prefix } from '../directives'\nimport { mutateDom } from '../mutation'\n\ndirective('cloak', el => queueMicrotask(() => mutateDom(() => el.removeAttribute(prefix('cloak')))))\n","import { directive, prefix } from \"../directives\";\nimport { addInitSelector } from \"../lifecycle\";\nimport { skipDuringClone } from \"../clone\";\n\naddInitSelector(() => `[${prefix('init')}]`)\n\ndirective('init', skipDuringClone((el, { expression }, { evaluate }) => {\n    if (typeof expression === 'string') {\n        return !! expression.trim() && evaluate(expression, {}, false)\n    }\n\n    return evaluate(expression, {}, false)\n}))\n","import { directive } from '../directives'\nimport { mutateDom } from '../mutation'\n\ndirective('text', (el, { expression }, { effect, evaluateLater }) => {\n    let evaluate = evaluateLater(expression)\n\n    effect(() => {\n        evaluate(value => {\n            mutateDom(() => {\n                el.textContent = value\n            })\n        })\n    })\n})\n","import { directive } from '../directives'\nimport { initTree } from '../lifecycle'\nimport { mutateDom } from '../mutation'\n\ndirective('html', (el, { expression }, { effect, evaluateLater }) => {\n    let evaluate = evaluateLater(expression)\n\n    effect(() => {\n        evaluate(value => {\n            mutateDom(() => {\n                el.innerHTML = value\n\n                el._x_ignoreSelf = true\n                initTree(el)\n                delete el._x_ignoreSelf\n            })\n        })\n    })\n})\n","import { directive, into, mapAttributes, prefix, startingWith } from '../directives'\nimport { evaluateLater } from '../evaluator'\nimport { mutateDom } from '../mutation'\nimport bind from '../utils/bind'\nimport { applyBindingsObject, injectBindingProviders } from '../binds'\n\nmapAttributes(startingWith(':', into(prefix('bind:'))))\n\nlet handler = (el, { value, modifiers, expression, original }, { effect }) => {\n    if (! value) {\n        let bindingProviders = {}\n        injectBindingProviders(bindingProviders)\n\n        let getBindings = evaluateLater(el, expression)\n\n        getBindings(bindings => {\n            applyBindingsObject(el, bindings, original)\n        }, { scope: bindingProviders } )\n\n        return\n    }\n\n    if (value === 'key') return storeKeyForXFor(el, expression)\n\n    if (el._x_inlineBindings && el._x_inlineBindings[value] && el._x_inlineBindings[value].extract) {\n        return\n    }\n\n    let evaluate = evaluateLater(el, expression)\n\n    effect(() => evaluate(result => {\n        // If nested object key is undefined, set the default value to empty string.\n        if (result === undefined && typeof expression === 'string' && expression.match(/\\./)) {\n            result = ''\n        }\n\n        mutateDom(() => bind(el, value, result, modifiers))\n    }))\n}\n\n// @todo: see if I can take advantage of the object created here inside the\n// non-inline handler above so we're not duplicating work twice...\nhandler.inline = (el, { value, modifiers, expression }) => {\n    if (! value) return;\n\n    if (! el._x_inlineBindings) el._x_inlineBindings = {}\n\n    el._x_inlineBindings[value] = { expression, extract: false }\n}\n\ndirective('bind', handler)\n\nfunction storeKeyForXFor(el, expression) {\n    el._x_keyExpression = expression\n}\n","import { directive, prefix } from '../directives'\nimport { initInterceptors } from '../interceptor'\nimport { injectDataProviders } from '../datas'\nimport { addRootSelector } from '../lifecycle'\nimport { interceptClone, isCloning, isCloningLegacy } from '../clone'\nimport { addScopeToNode } from '../scope'\nimport { injectMagics, magic } from '../magics'\nimport { reactive } from '../reactivity'\nimport { evaluate } from '../evaluator'\n\naddRootSelector(() => `[${prefix('data')}]`)\n\ndirective('data', ((el, { expression }, { cleanup }) => {\n    if (shouldSkipRegisteringDataDuringClone(el)) return\n\n    expression = expression === '' ? '{}' : expression\n\n    let magicContext = {}\n    injectMagics(magicContext, el)\n\n    let dataProviderContext = {}\n    injectDataProviders(dataProviderContext, magicContext)\n\n    let data = evaluate(el, expression, { scope: dataProviderContext })\n\n    if (data === undefined || data === true) data = {}\n\n    injectMagics(data, el)\n\n    let reactiveData = reactive(data)\n\n    initInterceptors(reactiveData)\n\n    let undo = addScopeToNode(el, reactiveData)\n\n    reactiveData['init'] && evaluate(el, reactiveData['init'])\n\n    cleanup(() => {\n        reactiveData['destroy'] && evaluate(el, reactiveData['destroy'])\n\n        undo()\n    })\n}))\n\ninterceptClone((from, to) => {\n    // Transfer over existing runtime Alpine state from\n    // the existing dom tree over to the new one...\n    if (from._x_dataStack) {\n        to._x_dataStack = from._x_dataStack\n\n        // Set a flag to signify the new tree is using\n        // pre-seeded state (used so x-data knows when\n        // and when not to initialize state)...\n        to.setAttribute('data-has-alpine-state', true)\n    }\n})\n\n// If we are cloning a tree, we only want to evaluate x-data if another\n// x-data context DOESN'T exist on the component.\n// The reason a data context WOULD exist is that we graft root x-data state over\n// from the live tree before hydrating the clone tree.\nfunction shouldSkipRegisteringDataDuringClone(el) {\n    if (! isCloning) return false\n    if (isCloningLegacy) return true\n\n    return el.hasAttribute('data-has-alpine-state')\n}\n","import { evaluateLater } from '../evaluator'\nimport { directive } from '../directives'\nimport { mutateDom } from '../mutation'\nimport { once } from '../utils/once'\n\ndirective('show', (el, { modifiers, expression }, { effect }) => {\n    let evaluate = evaluateLater(el, expression)\n\n    // We're going to set this function on the element directly so that\n    // other plugins like \"Collapse\" can overwrite them with their own logic.\n    if (! el._x_doHide) el._x_doHide = () => {\n        mutateDom(() => {\n            el.style.setProperty('display', 'none', modifiers.includes('important') ? 'important' : undefined)\n        })\n    }\n\n    if (! el._x_doShow) el._x_doShow = () => {\n        mutateDom(() => {\n            if (el.style.length === 1 && el.style.display === 'none') {\n                el.removeAttribute('style')\n            } else {\n                el.style.removeProperty('display')\n            }\n        })\n    }\n\n    let hide = () => {\n        el._x_doHide()\n        el._x_isShown = false\n    }\n\n    let show = () => {\n        el._x_doShow()\n        el._x_isShown = true\n    }\n\n    // We are wrapping this function in a setTimeout here to prevent\n    // a race condition from happening where elements that have a\n    // @click.away always view themselves as shown on the page.\n    let clickAwayCompatibleShow = () => setTimeout(show)\n\n    let toggle = once(\n        value => value ? show() : hide(),\n        value => {\n            if (typeof el._x_toggleAndCascadeWithTransitions === 'function') {\n                el._x_toggleAndCascadeWithTransitions(el, value, show, hide)\n            } else {\n                value ? clickAwayCompatibleShow() : hide()\n            }\n        }\n    )\n\n    let oldValue\n    let firstTime = true\n\n    effect(() => evaluate(value => {\n        // Let's make sure we only call this effect if the value changed.\n        // This prevents \"blip\" transitions. (1 tick out, then in)\n        if (! firstTime && value === oldValue) return\n\n        if (modifiers.includes('immediate')) value ? clickAwayCompatibleShow() : hide()\n\n        toggle(value)\n\n        oldValue = value\n        firstTime = false\n    }))\n})\n","import { addScopeToNode } from '../scope'\nimport { evaluateLater } from '../evaluator'\nimport { directive } from '../directives'\nimport { reactive } from '../reactivity'\nimport { initTree } from '../lifecycle'\nimport { mutateDom } from '../mutation'\nimport { flushJobs } from '../scheduler'\nimport { warn } from '../utils/warn'\nimport { dequeueJob } from '../scheduler'\n\ndirective('for', (el, { expression }, { effect, cleanup }) => {\n    let iteratorNames = parseForExpression(expression)\n\n    let evaluateItems = evaluateLater(el, iteratorNames.items)\n    let evaluateKey = evaluateLater(el,\n        // the x-bind:key expression is stored for our use instead of evaluated.\n        el._x_keyExpression || 'index'\n    )\n\n    el._x_prevKeys = []\n    el._x_lookup = {}\n\n    effect(() => loop(el, iteratorNames, evaluateItems, evaluateKey))\n\n    cleanup(() => {\n        Object.values(el._x_lookup).forEach(el => el.remove())\n\n        delete el._x_prevKeys\n        delete el._x_lookup\n    })\n})\n\nlet shouldFastRender = true\n\nfunction loop(el, iteratorNames, evaluateItems, evaluateKey) {\n    let isObject = i => typeof i === 'object' && ! Array.isArray(i)\n    let templateEl = el\n\n    evaluateItems(items => {\n        // Prepare yourself. There's a lot going on here. Take heart,\n        // every bit of complexity in this function was added for\n        // the purpose of making Alpine fast with large datas.\n\n        // Support number literals. Ex: x-for=\"i in 100\"\n        if (isNumeric(items) && items >= 0) {\n            items = Array.from(Array(items).keys(), i => i + 1)\n        }\n\n        if (items === undefined) items = []\n\n        let lookup = el._x_lookup\n        let prevKeys = el._x_prevKeys\n        let scopes = []\n        let keys = []\n\n        // In order to preserve DOM elements (move instead of replace)\n        // we need to generate all the keys for every iteration up\n        // front. These will be our source of truth for diffing.\n        if (isObject(items)) {\n            items = Object.entries(items).map(([key, value]) => {\n                let scope = getIterationScopeVariables(iteratorNames, value, key, items)\n\n                evaluateKey(value => keys.push(value), { scope: { index: key, ...scope} })\n\n                scopes.push(scope)\n            })\n        } else {\n            for (let i = 0; i < items.length; i++) {\n                let scope = getIterationScopeVariables(iteratorNames, items[i], i, items)\n\n                evaluateKey(value => keys.push(value), { scope: { index: i, ...scope} })\n\n                scopes.push(scope)\n            }\n        }\n\n        // Rather than making DOM manipulations inside one large loop, we'll\n        // instead track which mutations need to be made in the following\n        // arrays. After we're finished, we can batch them at the end.\n        let adds = []\n        let moves = []\n        let removes = []\n        let sames = []\n\n        // First, we track elements that will need to be removed.\n        for (let i = 0; i < prevKeys.length; i++) {\n            let key = prevKeys[i]\n\n            if (keys.indexOf(key) === -1) removes.push(key)\n        }\n\n        // Notice we're mutating prevKeys as we go. This makes it\n        // so that we can efficiently make incremental comparisons.\n        prevKeys = prevKeys.filter(key => ! removes.includes(key))\n\n        let lastKey = 'template'\n\n        // This is the important part of the diffing algo. Identifying\n        // which keys (future DOM elements) are new, which ones have\n        // or haven't moved (noting where they moved to / from).\n        for (let i = 0; i < keys.length; i++) {\n            let key = keys[i]\n\n            let prevIndex = prevKeys.indexOf(key)\n\n            if (prevIndex === -1) {\n                // New key found.\n                prevKeys.splice(i, 0, key)\n\n                adds.push([lastKey, i])\n            } else if (prevIndex !== i) {\n                // A key has moved.\n                let keyInSpot = prevKeys.splice(i, 1)[0]\n                let keyForSpot = prevKeys.splice(prevIndex - 1, 1)[0]\n\n                prevKeys.splice(i, 0, keyForSpot)\n                prevKeys.splice(prevIndex, 0, keyInSpot)\n\n                moves.push([keyInSpot, keyForSpot])\n            } else {\n                // This key hasn't moved, but we'll still keep track\n                // so that we can refresh it later on.\n                sames.push(key)\n            }\n\n            lastKey = key\n        }\n\n        // Now that we've done the diffing work, we can apply the mutations\n        // in batches for both separating types work and optimizing\n        // for browser performance.\n\n        // We'll remove all the nodes that need to be removed,\n        // letting the mutation observer pick them up and\n        // clean up any side effects they had.\n        for (let i = 0; i < removes.length; i++) {\n            let key = removes[i]\n\n            // Remove any queued effects that might run after the DOM node has been removed.\n            if (!! lookup[key]._x_effects) {\n                lookup[key]._x_effects.forEach(dequeueJob)\n            }\n\n            lookup[key].remove()\n\n            lookup[key] = null\n            delete lookup[key]\n        }\n\n        // Here we'll move elements around, skipping\n        // mutation observer triggers by using \"mutateDom\".\n        for (let i = 0; i < moves.length; i++) {\n            let [keyInSpot, keyForSpot] = moves[i]\n\n            let elInSpot = lookup[keyInSpot]\n            let elForSpot = lookup[keyForSpot]\n\n            let marker = document.createElement('div')\n\n            mutateDom(() => {\n                if (! elForSpot) warn(`x-for \":key\" is undefined or invalid`, templateEl)\n\n                elForSpot.after(marker)\n                elInSpot.after(elForSpot)\n                elForSpot._x_currentIfEl && elForSpot.after(elForSpot._x_currentIfEl)\n                marker.before(elInSpot)\n                elInSpot._x_currentIfEl && elInSpot.after(elInSpot._x_currentIfEl)\n                marker.remove()\n            })\n\n            elForSpot._x_refreshXForScope(scopes[keys.indexOf(keyForSpot)])\n        }\n\n        // We can now create and add new elements.\n        for (let i = 0; i < adds.length; i++) {\n            let [lastKey, index] = adds[i]\n\n            let lastEl = (lastKey === 'template') ? templateEl : lookup[lastKey]\n            // If the element is a x-if template evaluated to true,\n            // point lastEl to the if-generated node\n            if (lastEl._x_currentIfEl) lastEl = lastEl._x_currentIfEl\n\n            let scope = scopes[index]\n            let key = keys[index]\n\n            let clone = document.importNode(templateEl.content, true).firstElementChild\n\n            let reactiveScope = reactive(scope)\n\n            addScopeToNode(clone, reactiveScope, templateEl)\n\n            clone._x_refreshXForScope = (newScope) => {\n                Object.entries(newScope).forEach(([key, value]) => {\n                    reactiveScope[key] = value\n                })\n            }\n\n            mutateDom(() => {\n                lastEl.after(clone)\n\n                initTree(clone)\n            })\n\n            if (typeof key === 'object') {\n                warn('x-for key cannot be an object, it must be a string or an integer', templateEl)\n            }\n\n            lookup[key] = clone\n        }\n\n        // If an element hasn't changed, we still want to \"refresh\" the\n        // data it depends on in case the data has changed in an\n        // \"unobservable\" way.\n        for (let i = 0; i < sames.length; i++) {\n            lookup[sames[i]]._x_refreshXForScope(scopes[keys.indexOf(sames[i])])\n        }\n\n        // Now we'll log the keys (and the order they're in) for comparing\n        // against next time.\n        templateEl._x_prevKeys = keys\n    })\n}\n\n// This was taken from VueJS 2.* core. Thanks Vue!\nfunction parseForExpression(expression) {\n    let forIteratorRE = /,([^,\\}\\]]*)(?:,([^,\\}\\]]*))?$/\n    let stripParensRE = /^\\s*\\(|\\)\\s*$/g\n    let forAliasRE = /([\\s\\S]*?)\\s+(?:in|of)\\s+([\\s\\S]*)/\n    let inMatch = expression.match(forAliasRE)\n\n    if (! inMatch) return\n\n    let res = {}\n    res.items = inMatch[2].trim()\n    let item = inMatch[1].replace(stripParensRE, '').trim()\n    let iteratorMatch = item.match(forIteratorRE)\n\n    if (iteratorMatch) {\n        res.item = item.replace(forIteratorRE, '').trim()\n        res.index = iteratorMatch[1].trim()\n\n        if (iteratorMatch[2]) {\n            res.collection = iteratorMatch[2].trim()\n        }\n    } else {\n        res.item = item\n    }\n\n    return res\n}\n\nfunction getIterationScopeVariables(iteratorNames, item, index, items) {\n    // We must create a new object, so each iteration has a new scope\n    let scopeVariables = {}\n\n    // Support array destructuring ([foo, bar]).\n    if (/^\\[.*\\]$/.test(iteratorNames.item) && Array.isArray(item)) {\n        let names = iteratorNames.item.replace('[', '').replace(']', '').split(',').map(i => i.trim())\n\n        names.forEach((name, i) => {\n            scopeVariables[name] = item[i]\n        })\n    // Support object destructuring ({ foo: 'oof', bar: 'rab' }).\n    } else if (/^\\{.*\\}$/.test(iteratorNames.item) && ! Array.isArray(item) && typeof item === 'object') {\n        let names = iteratorNames.item.replace('{', '').replace('}', '').split(',').map(i => i.trim())\n\n        names.forEach(name => {\n            scopeVariables[name] = item[name]\n        })\n    } else {\n        scopeVariables[iteratorNames.item] = item\n    }\n\n    if (iteratorNames.index) scopeVariables[iteratorNames.index] = index\n\n    if (iteratorNames.collection) scopeVariables[iteratorNames.collection] = items\n\n    return scopeVariables\n}\n\nfunction isNumeric(subject){\n    return ! Array.isArray(subject) && ! isNaN(subject)\n}\n","import { closestRoot } from '../lifecycle'\nimport { directive } from '../directives'\n\nfunction handler () {}\n\nhandler.inline = (el, { expression }, { cleanup }) => {\n    let root = closestRoot(el)\n\n    if (! root._x_refs) root._x_refs = {}\n\n    root._x_refs[expression] = el\n\n    cleanup(() => delete root._x_refs[expression])\n}\n\ndirective('ref', handler)\n","import { evaluateLater } from '../evaluator'\nimport { addScopeToNode } from '../scope'\nimport { directive } from '../directives'\nimport { initTree } from '../lifecycle'\nimport { mutateDom } from '../mutation'\nimport { walk } from \"../utils/walk\"\nimport { dequeueJob } from '../scheduler'\nimport { warn } from \"../utils/warn\"\n\ndirective('if', (el, { expression }, { effect, cleanup }) => {\n    if (el.tagName.toLowerCase() !== 'template') warn('x-if can only be used on a <template> tag', el)\n\n    let evaluate = evaluateLater(el, expression)\n\n    let show = () => {\n        if (el._x_currentIfEl) return el._x_currentIfEl\n\n        let clone = el.content.cloneNode(true).firstElementChild\n\n        addScopeToNode(clone, {}, el)\n\n        mutateDom(() => {\n            el.after(clone)\n\n            initTree(clone)\n        })\n\n        el._x_currentIfEl = clone\n\n        el._x_undoIf = () => {\n            walk(clone, (node) => {\n                if (!!node._x_effects) {\n                    node._x_effects.forEach(dequeueJob)\n                }\n            })\n            \n            clone.remove();\n\n            delete el._x_currentIfEl\n        }\n\n        return clone\n    }\n\n    let hide = () => {\n        if (! el._x_undoIf) return\n\n        el._x_undoIf()\n\n        delete el._x_undoIf\n    }\n\n    effect(() => evaluate(value => {\n        value ? show() : hide()\n    }))\n\n    cleanup(() => el._x_undoIf && el._x_undoIf())\n})\n","import { interceptClone } from \"../clone\"\nimport { directive } from \"../directives\"\nimport { setIdRoot } from '../ids'\n\ndirective('id', (el, { expression }, { evaluate }) => {\n    let names = evaluate(expression)\n\n    names.forEach(name => setIdRoot(el, name))\n})\n\ninterceptClone((from, to) => {\n    // Transfer over existing ID registrations from\n    // the existing dom tree over to the new one\n    // so that there aren't ID mismatches...\n    if (from._x_ids) {\n        to._x_ids = from._x_ids\n    }\n})\n\n","import { directive, into, mapAttributes, prefix, startingWith } from '../directives'\nimport { evaluateLater } from '../evaluator'\nimport { skipDuringClone } from '../clone'\nimport on from '../utils/on'\n\nmapAttributes(startingWith('@', into(prefix('on:'))))\n\ndirective('on', skipDuringClone((el, { value, modifiers, expression }, { cleanup }) => {\n    let evaluate = expression ? evaluateLater(el, expression) : () => {}\n\n    // Forward event listeners on portals.\n    if (el.tagName.toLowerCase() === 'template') {\n        if (! el._x_forwardEvents) el._x_forwardEvents = []\n        if (! el._x_forwardEvents.includes(value)) el._x_forwardEvents.push(value)\n    }\n\n    let removeListener = on(el, value, modifiers, e => {\n        evaluate(() => {}, { scope: { '$event': e }, params: [e] })\n    })\n\n    cleanup(() => removeListener())\n}))\n","import { directive } from '../directives'\nimport { warn } from '../utils/warn'\n\nimport './x-transition'\nimport './x-modelable'\nimport './x-teleport'\nimport './x-ignore'\nimport './x-effect'\nimport './x-model'\nimport './x-cloak'\nimport './x-init'\nimport './x-text'\nimport './x-html'\nimport './x-bind'\nimport './x-data'\nimport './x-show'\nimport './x-for'\nimport './x-ref'\nimport './x-if'\nimport './x-id'\nimport './x-on'\n\n// Register warnings for people using plugin syntaxes and not loading the plugin itself:\nwarnMissingPluginDirective('Collapse', 'collapse', 'collapse')\nwarnMissingPluginDirective('Intersect', 'intersect', 'intersect')\nwarnMissingPluginDirective('Focus', 'trap', 'focus')\nwarnMissingPluginDirective('Mask', 'mask', 'mask')\n\nfunction warnMissingPluginDirective(name, directiveName, slug) {\n    directive(directiveName, (el) => warn(`You can't use [x-${directiveName}] without first installing the \"${name}\" plugin here: https://alpinejs.dev/plugins/${slug}`, el))\n}\n"],"names":["directive","el","expression","effect","evaluateLater","cleanup","func","innerGet","result","i","evaluateInnerSet","innerSet","val","scope","__placeholder","initialValue","queueMicrotask","_x_model","_x_removeModelListeners","outerGet","get","outerSet","set","releaseEntanglement","entangle","value","modifiers","tagName","toLowerCase","warn","target","getTarget","clone","content","cloneNode","firstElementChild","_x_teleport","_x_teleportBack","setAttribute","_x_forwardEvents","forEach","eventName","addEventListener","e","stopPropagation","dispatchEvent","constructor","type","addScopeToNode","placeInDom","includes","parentNode","insertBefore","nextSibling","appendChild","mutateDom","initTree","_x_ignore","_x_teleportPutBack","remove","teleportContainerDuringClone","document","createElement","skipDuringClone","querySelector","handler","inline","_x_ignoreSelf","scopeTarget","evaluateGet","evaluateSet","getValue","isGetterSetter","setValue","hasAttribute","event","removeListener","isCloning","on","getInputValue","undefined","Array","isArray","Event","form","removeResetListener","nextTick","_x_forceModelUpdate","match","window","fromModel","bind","activeElement","isSameNode","currentValue","CustomEvent","detail","newValue","safeParseNumber","safeParseBoolean","checked","concat","filter","checkedAttrLooseCompare","multiple","from","selectedOptions","map","option","rawValue","text","trim","number","parseFloat","isNumeric","valueA","valueB","subject","isNaN","removeAttribute","prefix","addInitSelector","evaluate","textContent","innerHTML","mapAttributes","startingWith","into","original","bindingProviders","injectBindingProviders","getBindings","bindings","applyBindingsObject","storeKeyForXFor","_x_inlineBindings","extract","_x_keyExpression","addRootSelector","shouldSkipRegisteringDataDuringClone","magicContext","injectMagics","dataProviderContext","injectDataProviders","data","reactiveData","reactive","initInterceptors","undo","interceptClone","to","_x_dataStack","isCloningLegacy","_x_doHide","style","setProperty","_x_doShow","length","display","removeProperty","hide","_x_isShown","show","clickAwayCompatibleShow","setTimeout","toggle","once","_x_toggleAndCascadeWithTransitions","oldValue","firstTime","iteratorNames","parseForExpression","evaluateItems","items","evaluateKey","_x_prevKeys","_x_lookup","loop","Object","values","isObject","templateEl","keys","lookup","prevKeys","scopes","entries","key","getIterationScopeVariables","push","index","adds","moves","removes","sames","indexOf","lastKey","prevIndex","splice","keyInSpot","keyForSpot","_x_effects","dequeueJob","elInSpot","elForSpot","marker","after","_x_currentIfEl","before","_x_refreshXForScope","lastEl","importNode","reactiveScope","newScope","forIteratorRE","stripParensRE","forAliasRE","inMatch","res","item","replace","iteratorMatch","collection","scopeVariables","test","names","split","name","root","closestRoot","_x_refs","_x_undoIf","walk","node","setIdRoot","_x_ids","$event","params","warnMissingPluginDirective","directiveName","slug"],"mappings":"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"}