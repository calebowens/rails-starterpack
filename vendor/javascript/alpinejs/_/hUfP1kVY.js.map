// alpinejs@3.13.5/_/hUfP1kVY.js.map downloaded from https://ga.jspm.io/npm:alpinejs@3.13.5/_/hUfP1kVY.js.map

{"version":3,"file":"hUfP1kVY.js","sources":["../src/utils/warn.js","../src/scheduler.js","../src/reactivity.js","../src/utils/dispatch.js","../src/utils/walk.js","../src/lifecycle.js","../src/mutation.js","../src/evaluator.js","../src/directives.js","../src/nextTick.js","../src/utils/classes.js","../src/utils/styles.js","../src/directives/x-transition.js","../src/clone.js","../src/interceptor.js","../src/utils/bind.js","../src/entangle.js","../src/plugin.js","../src/store.js","../src/binds.js","../src/datas.js","../src/alpine.js","../src/magics.js"],"sourcesContent":["\nexport function warn(message, ...args) {\n    console.warn(`Alpine Warning: ${message}`, ...args)\n}\n","\nlet flushPending = false\nlet flushing = false\nlet queue = []\nlet lastFlushedIndex = -1\n\nexport function scheduler (callback) { queueJob(callback) }\n\nfunction queueJob(job) {\n    if (! queue.includes(job)) queue.push(job)\n\n    queueFlush()\n}\nexport function dequeueJob(job) {\n    let index = queue.indexOf(job)\n\n    if (index !== -1 && index > lastFlushedIndex) queue.splice(index, 1)\n}\n\nfunction queueFlush() {\n    if (! flushing && ! flushPending) {\n        flushPending = true\n\n        queueMicrotask(flushJobs)\n    }\n}\n\nexport function flushJobs() {\n    flushPending = false\n    flushing = true\n\n    for (let i = 0; i < queue.length; i++) {\n        queue[i]()\n        lastFlushedIndex = i\n    }\n\n    queue.length = 0\n    lastFlushedIndex = -1\n\n    flushing = false\n}\n","\nimport { scheduler } from './scheduler'\n\nlet reactive, effect, release, raw\n\nlet shouldSchedule = true\nexport function disableEffectScheduling(callback) {\n    shouldSchedule = false\n\n    callback()\n\n    shouldSchedule = true\n}\n\nexport function setReactivityEngine(engine) {\n    reactive = engine.reactive\n    release = engine.release\n    effect = (callback) => engine.effect(callback, { scheduler: task => {\n        if (shouldSchedule) {\n            scheduler(task)\n        } else {\n            task()\n        }\n    } })\n    raw = engine.raw\n}\n\nexport function overrideEffect(override) { effect = override }\n\nexport function elementBoundEffect(el) {\n    let cleanup = () => {}\n\n    let wrappedEffect = (callback) => {\n        let effectReference = effect(callback)\n\n        if (! el._x_effects) {\n            el._x_effects = new Set\n\n            // Livewire depends on el._x_runEffects.\n            el._x_runEffects = () => { el._x_effects.forEach(i => i()) }\n        }\n\n        el._x_effects.add(effectReference)\n\n        cleanup = () => {\n            if (effectReference === undefined) return\n\n            el._x_effects.delete(effectReference)\n\n            release(effectReference)\n        }\n\n        return effectReference\n    }\n\n    return [wrappedEffect, () => { cleanup() }]\n}\n\nexport function watch(getter, callback) {\n    let firstTime = true\n\n    let oldValue\n\n    let effectReference = effect(() => {\n        let value = getter()\n\n        // JSON.stringify touches every single property at any level enabling deep watching\n        JSON.stringify(value)\n\n        if (! firstTime) {\n            // We have to queue this watcher as a microtask so that\n            // the watcher doesn't pick up its own dependencies.\n            queueMicrotask(() => {\n                callback(value, oldValue)\n\n                oldValue = value\n            })\n        } else {\n            oldValue = value\n        }\n\n        firstTime = false\n    })\n\n    return () => release(effectReference)\n}\n\nexport {\n    release,\n    reactive,\n    effect,\n    raw,\n}\n","\nexport function dispatch(el, name, detail = {}) {\n    el.dispatchEvent(\n        new CustomEvent(name, {\n            detail,\n            bubbles: true,\n            // Allows events to pass the shadow DOM barrier.\n            composed: true,\n            cancelable: true,\n        })\n    )\n}\n","export function walk(el, callback) {\n    if (typeof ShadowRoot === 'function' && el instanceof ShadowRoot) {\n        Array.from(el.children).forEach(el => walk(el, callback))\n\n        return\n    }\n\n    let skip = false\n\n    callback(el, () => skip = true)\n\n    if (skip) return\n\n    let node = el.firstElementChild\n\n    while (node) {\n        walk(node, callback, false)\n\n        node = node.nextElementSibling\n    }\n}\n","import { startObservingMutations, onAttributesAdded, onElAdded, onElRemoved, cleanupAttributes, cleanupElement } from \"./mutation\"\nimport { deferHandlingDirectives, directives } from \"./directives\"\nimport { dispatch } from './utils/dispatch'\nimport { walk } from \"./utils/walk\"\nimport { warn } from './utils/warn'\nimport Alpine from \"./alpine\"\n\nlet started = false\n\nexport function start() {\n    if (started) warn('Alpine has already been initialized on this page. Calling Alpine.start() more than once can cause problems.')\n\n    started = true\n\n    if (! document.body) warn('Unable to initialize. Trying to load Alpine before `<body>` is available. Did you forget to add `defer` in Alpine\\'s `<script>` tag?')\n\n    dispatch(document, 'alpine:init')\n    dispatch(document, 'alpine:initializing')\n\n    startObservingMutations()\n\n    onElAdded(el => initTree(el, walk))\n    onElRemoved(el => destroyTree(el))\n\n    onAttributesAdded((el, attrs) => {\n        directives(el, attrs).forEach(handle => handle())\n    })\n\n    let outNestedComponents = el => ! closestRoot(el.parentElement, true)\n    Array.from(document.querySelectorAll(allSelectors().join(',')))\n        .filter(outNestedComponents)\n        .forEach(el => {\n            initTree(el)\n        })\n\n    dispatch(document, 'alpine:initialized')\n}\n\nlet rootSelectorCallbacks = []\nlet initSelectorCallbacks = []\n\nexport function rootSelectors() {\n    return rootSelectorCallbacks.map(fn => fn())\n}\n\nexport function allSelectors() {\n    return rootSelectorCallbacks.concat(initSelectorCallbacks).map(fn => fn())\n}\n\nexport function addRootSelector(selectorCallback) { rootSelectorCallbacks.push(selectorCallback) }\nexport function addInitSelector(selectorCallback) { initSelectorCallbacks.push(selectorCallback) }\n\nexport function closestRoot(el, includeInitSelectors = false) {\n    return findClosest(el, element => {\n        const selectors = includeInitSelectors ? allSelectors() : rootSelectors()\n\n        if (selectors.some(selector => element.matches(selector))) return true\n    })\n}\n\nexport function findClosest(el, callback) {\n    if (! el) return\n\n    if (callback(el)) return el\n\n    // Support crawling up teleports.\n    if (el._x_teleportBack) el = el._x_teleportBack\n\n    if (! el.parentElement) return\n\n    return findClosest(el.parentElement, callback)\n}\n\nexport function isRoot(el) {\n    return rootSelectors().some(selector => el.matches(selector))\n}\n\nlet initInterceptors = []\n\nexport function interceptInit(callback) { initInterceptors.push(callback) }\n\nexport function initTree(el, walker = walk, intercept = () => {}) {\n    deferHandlingDirectives(() => {\n        walker(el, (el, skip) => {\n            intercept(el, skip)\n\n            initInterceptors.forEach(i => i(el, skip))\n\n            directives(el, el.attributes).forEach(handle => handle())\n\n            el._x_ignore && skip()\n        })\n    })\n}\n\nexport function destroyTree(root) {\n    walk(root, el => {\n        cleanupAttributes(el)\n        cleanupElement(el)\n    })\n}\n","import { destroyTree } from \"./lifecycle\"\n\nlet onAttributeAddeds = []\nlet onElRemoveds = []\nlet onElAddeds = []\n\nexport function onElAdded(callback) {\n    onElAddeds.push(callback)\n}\n\nexport function onElRemoved(el, callback) {\n    if (typeof callback === 'function') {\n        if (! el._x_cleanups) el._x_cleanups = []\n        el._x_cleanups.push(callback)\n    } else {\n        callback = el\n        onElRemoveds.push(callback)\n    }\n}\n\nexport function onAttributesAdded(callback) {\n    onAttributeAddeds.push(callback)\n}\n\nexport function onAttributeRemoved(el, name, callback) {\n    if (! el._x_attributeCleanups) el._x_attributeCleanups = {}\n    if (! el._x_attributeCleanups[name]) el._x_attributeCleanups[name] = []\n\n    el._x_attributeCleanups[name].push(callback)\n}\n\nexport function cleanupAttributes(el, names) {\n    if (! el._x_attributeCleanups) return\n\n    Object.entries(el._x_attributeCleanups).forEach(([name, value]) => {\n        if (names === undefined || names.includes(name)) {\n            value.forEach(i => i())\n\n            delete el._x_attributeCleanups[name]\n        }\n    })\n}\n\nexport function cleanupElement(el) {\n    if (el._x_cleanups) {\n        while (el._x_cleanups.length) el._x_cleanups.pop()()\n    }\n}\n\nlet observer = new MutationObserver(onMutate)\n\nlet currentlyObserving = false\n\nexport function startObservingMutations() {\n    observer.observe(document, { subtree: true, childList: true, attributes: true, attributeOldValue: true })\n\n    currentlyObserving = true\n}\n\nexport function stopObservingMutations() {\n    flushObserver()\n\n    observer.disconnect()\n\n    currentlyObserving = false\n}\n\nlet queuedMutations = []\n\nexport function flushObserver() {\n    let records = observer.takeRecords()\n\n    queuedMutations.push(() => records.length > 0 && onMutate(records))\n\n    let queueLengthWhenTriggered = queuedMutations.length\n\n    queueMicrotask(() => {\n        // If these two lengths match, then we KNOW that this is the LAST\n        // flush in the current event loop. This way, we can process\n        // all mutations in one batch at the end of everything...\n        if (queuedMutations.length === queueLengthWhenTriggered) {\n            // Now Alpine can process all the mutations...\n            while (queuedMutations.length > 0) queuedMutations.shift()()\n        }\n    })\n}\n\nexport function mutateDom(callback) {\n    if (! currentlyObserving) return callback()\n\n    stopObservingMutations()\n\n    let result = callback()\n\n    startObservingMutations()\n\n    return result\n}\n\nlet isCollecting = false\nlet deferredMutations = []\n\nexport function deferMutations() {\n    isCollecting = true\n}\n\nexport function flushAndStopDeferringMutations() {\n    isCollecting = false\n\n    onMutate(deferredMutations)\n\n    deferredMutations = []\n}\n\nfunction onMutate(mutations) {\n    if (isCollecting) {\n        deferredMutations = deferredMutations.concat(mutations)\n\n        return\n    }\n\n    let addedNodes = new Set\n    let removedNodes = new Set\n    let addedAttributes = new Map\n    let removedAttributes = new Map\n\n    for (let i = 0; i < mutations.length; i++) {\n        if (mutations[i].target._x_ignoreMutationObserver) continue\n\n        if (mutations[i].type === 'childList') {\n            mutations[i].addedNodes.forEach(node => node.nodeType === 1 && addedNodes.add(node))\n            mutations[i].removedNodes.forEach(node => node.nodeType === 1 && removedNodes.add(node))\n        }\n\n        if (mutations[i].type === 'attributes') {\n            let el = mutations[i].target\n            let name = mutations[i].attributeName\n            let oldValue = mutations[i].oldValue\n\n            let add = () => {\n                if (! addedAttributes.has(el)) addedAttributes.set(el, [])\n\n                addedAttributes.get(el).push({ name,  value: el.getAttribute(name) })\n            }\n\n            let remove = () => {\n                if (! removedAttributes.has(el)) removedAttributes.set(el, [])\n\n                removedAttributes.get(el).push(name)\n            }\n\n            // New attribute.\n            if (el.hasAttribute(name) && oldValue === null) {\n                add()\n            // Changed attribute.\n            } else if (el.hasAttribute(name)) {\n                remove()\n                add()\n            // Removed attribute.\n            } else {\n                remove()\n            }\n        }\n    }\n\n    removedAttributes.forEach((attrs, el) => {\n        cleanupAttributes(el, attrs)\n    })\n\n    addedAttributes.forEach((attrs, el) => {\n        onAttributeAddeds.forEach(i => i(el, attrs))\n    })\n\n    for (let node of removedNodes) {\n        // If an element gets moved on a page, it's registered\n        // as both an \"add\" and \"remove\", so we want to skip those.\n        if (addedNodes.has(node)) continue\n\n        onElRemoveds.forEach(i => i(node))\n\n        destroyTree(node)\n    }\n\n    // Mutations are bundled together by the browser but sometimes\n    // for complex cases, there may be javascript code adding a wrapper\n    // and then an alpine component as a child of that wrapper in the same\n    // function and the mutation observer will receive 2 different mutations.\n    // when it comes time to run them, the dom contains both changes so the child\n    // element would be processed twice as Alpine calls initTree on\n    // both mutations. We mark all nodes as _x_ignored and only remove the flag\n    // when processing the node to avoid those duplicates.\n    addedNodes.forEach((node) => {\n        node._x_ignoreSelf = true\n        node._x_ignore = true\n    })\n    for (let node of addedNodes) {\n        // If the node was eventually removed as part of one of his\n        // parent mutations, skip it\n        if (removedNodes.has(node)) continue\n        if (! node.isConnected) continue\n\n        delete node._x_ignoreSelf\n        delete node._x_ignore\n        onElAddeds.forEach(i => i(node))\n        node._x_ignore = true\n        node._x_ignoreSelf = true\n    }\n    addedNodes.forEach((node) => {\n        delete node._x_ignoreSelf\n        delete node._x_ignore\n    })\n\n    addedNodes = null\n    removedNodes = null\n    addedAttributes = null\n    removedAttributes = null\n}\n","import { closestDataStack, mergeProxies } from './scope'\nimport { injectMagics } from './magics'\nimport { tryCatch, handleError } from './utils/error'\n\nlet shouldAutoEvaluateFunctions = true\n\nexport function dontAutoEvaluateFunctions(callback) {\n    let cache = shouldAutoEvaluateFunctions\n\n    shouldAutoEvaluateFunctions = false\n\n    let result = callback()\n\n    shouldAutoEvaluateFunctions = cache\n\n    return result\n}\n\nexport function evaluate(el, expression, extras = {}) {\n    let result\n\n    evaluateLater(el, expression)(value => result = value, extras)\n\n    return result\n}\n\nexport function evaluateLater(...args) {\n    return theEvaluatorFunction(...args)\n}\n\nlet theEvaluatorFunction = normalEvaluator\n\nexport function setEvaluator(newEvaluator) {\n    theEvaluatorFunction = newEvaluator\n}\n\nexport function normalEvaluator(el, expression) {\n    let overriddenMagics = {}\n\n    injectMagics(overriddenMagics, el)\n\n    let dataStack = [overriddenMagics, ...closestDataStack(el)]\n\n    let evaluator = (typeof expression === 'function')\n        ? generateEvaluatorFromFunction(dataStack, expression)\n        : generateEvaluatorFromString(dataStack, expression, el)\n\n    return tryCatch.bind(null, el, expression, evaluator)\n}\n\nexport function generateEvaluatorFromFunction(dataStack, func) {\n    return (receiver = () => {}, { scope = {}, params = [] } = {}) => {\n        let result = func.apply(mergeProxies([scope, ...dataStack]), params)\n\n        runIfTypeOfFunction(receiver, result)\n    }\n}\n\nlet evaluatorMemo = {}\n\nfunction generateFunctionFromString(expression, el) {\n    if (evaluatorMemo[expression]) {\n        return evaluatorMemo[expression]\n    }\n\n    let AsyncFunction = Object.getPrototypeOf(async function(){}).constructor\n\n    // Some expressions that are useful in Alpine are not valid as the right side of an expression.\n    // Here we'll detect if the expression isn't valid for an assignment and wrap it in a self-\n    // calling function so that we don't throw an error AND a \"return\" statement can b e used.\n    let rightSideSafeExpression = 0\n        // Support expressions starting with \"if\" statements like: \"if (...) doSomething()\"\n        || /^[\\n\\s]*if.*\\(.*\\)/.test(expression.trim())\n        // Support expressions starting with \"let/const\" like: \"let foo = 'bar'\"\n        || /^(let|const)\\s/.test(expression.trim())\n            ? `(async()=>{ ${expression} })()`\n            : expression\n\n    const safeAsyncFunction = () => {\n        try {\n            let func = new AsyncFunction(\n                [\"__self\", \"scope\"],\n                `with (scope) { __self.result = ${rightSideSafeExpression} }; __self.finished = true; return __self.result;`\n            )\n            \n            Object.defineProperty(func, \"name\", {\n                value: `[Alpine] ${expression}`,\n            })\n            \n            return func\n        } catch ( error ) {\n            handleError( error, el, expression )\n            return Promise.resolve()\n        }\n    }\n    let func = safeAsyncFunction()\n\n    evaluatorMemo[expression] = func\n\n    return func\n}\n\nfunction generateEvaluatorFromString(dataStack, expression, el) {\n    let func = generateFunctionFromString(expression, el)\n\n    return (receiver = () => {}, { scope = {}, params = [] } = {}) => {\n        func.result = undefined\n        func.finished = false\n\n        // Run the function.\n\n        let completeScope = mergeProxies([ scope, ...dataStack ])\n\n        if (typeof func === 'function' ) {\n            let promise = func(func, completeScope).catch((error) => handleError(error, el, expression))\n\n            // Check if the function ran synchronously,\n            if (func.finished) {\n                // Return the immediate result.\n                runIfTypeOfFunction(receiver, func.result, completeScope, params, el)\n                // Once the function has run, we clear func.result so we don't create\n                // memory leaks. func is stored in the evaluatorMemo and every time\n                // it runs, it assigns the evaluated expression to result which could\n                // potentially store a reference to the DOM element that will be removed later on.\n                func.result = undefined\n            } else {\n                // If not, return the result when the promise resolves.\n                promise.then(result => {\n                    runIfTypeOfFunction(receiver, result, completeScope, params, el)\n                }).catch( error => handleError( error, el, expression ) )\n                .finally( () => func.result = undefined )\n            }\n        }\n    }\n}\n\nexport function runIfTypeOfFunction(receiver, value, scope, params, el) {\n    if (shouldAutoEvaluateFunctions && typeof value === 'function') {\n        let result = value.apply(scope, params)\n\n        if (result instanceof Promise) {\n            result.then(i => runIfTypeOfFunction(receiver, i, scope, params)).catch( error => handleError( error, el, value ) )\n        } else {\n            receiver(result)\n        }\n    } else if (typeof value === 'object' && value instanceof Promise) {\n        value.then(i => receiver(i))\n    } else {\n        receiver(value)\n    }\n}\n","import { onAttributeRemoved, onElRemoved } from './mutation'\nimport { evaluate, evaluateLater } from './evaluator'\nimport { elementBoundEffect } from './reactivity'\nimport Alpine from './alpine'\n\nlet prefixAsString = 'x-'\n\nexport function prefix(subject = '') {\n    return prefixAsString + subject\n}\n\nexport function setPrefix(newPrefix) {\n    prefixAsString = newPrefix\n}\n\nlet directiveHandlers = {}\n\nexport function directive(name, callback) {\n    directiveHandlers[name] = callback\n\n    return {\n        before(directive) {\n            if (!directiveHandlers[directive]) {\n                console.warn(String.raw`Cannot find directive \\`${directive}\\`. \\`${name}\\` will use the default order of execution`);\n                return;\n            }\n            const pos = directiveOrder.indexOf(directive);\n            directiveOrder.splice(pos >= 0 ? pos : directiveOrder.indexOf('DEFAULT'), 0, name);\n        }\n    }\n}\n\nexport function directives(el, attributes, originalAttributeOverride) {\n    attributes = Array.from(attributes)\n\n    if (el._x_virtualDirectives) {\n        let vAttributes = Object.entries(el._x_virtualDirectives).map(([name, value]) => ({ name, value }))\n\n        let staticAttributes = attributesOnly(vAttributes)\n\n        // Handle binding normal HTML attributes (non-Alpine directives).\n        vAttributes = vAttributes.map(attribute => {\n            if (staticAttributes.find(attr => attr.name === attribute.name)) {\n                return {\n                    name: `x-bind:${attribute.name}`,\n                    value: `\"${attribute.value}\"`,\n                }\n            }\n\n            return attribute\n        })\n\n        attributes = attributes.concat(vAttributes)\n    }\n\n    let transformedAttributeMap = {}\n\n    let directives = attributes\n        .map(toTransformedAttributes((newName, oldName) => transformedAttributeMap[newName] = oldName))\n        .filter(outNonAlpineAttributes)\n        .map(toParsedDirectives(transformedAttributeMap, originalAttributeOverride))\n        .sort(byPriority)\n\n    return directives.map(directive => {\n        return getDirectiveHandler(el, directive)\n    })\n}\n\nexport function attributesOnly(attributes) {\n    return Array.from(attributes)\n        .map(toTransformedAttributes())\n        .filter(attr => ! outNonAlpineAttributes(attr))\n}\n\nlet isDeferringHandlers = false\nlet directiveHandlerStacks = new Map\nlet currentHandlerStackKey = Symbol()\n\nexport function deferHandlingDirectives(callback) {\n    isDeferringHandlers = true\n\n    let key = Symbol()\n\n    currentHandlerStackKey = key\n\n    directiveHandlerStacks.set(key, [])\n\n    let flushHandlers = () => {\n        while (directiveHandlerStacks.get(key).length) directiveHandlerStacks.get(key).shift()()\n\n        directiveHandlerStacks.delete(key)\n    }\n\n    let stopDeferring = () => { isDeferringHandlers = false; flushHandlers() }\n\n    callback(flushHandlers)\n\n    stopDeferring()\n}\n\nexport function getElementBoundUtilities(el) {\n    let cleanups = []\n\n    let cleanup = callback => cleanups.push(callback)\n\n    let [effect, cleanupEffect] = elementBoundEffect(el)\n\n    cleanups.push(cleanupEffect)\n\n    let utilities = {\n        Alpine,\n        effect,\n        cleanup,\n        evaluateLater: evaluateLater.bind(evaluateLater, el),\n        evaluate: evaluate.bind(evaluate, el),\n    }\n\n    let doCleanup = () => cleanups.forEach(i => i())\n\n    return [utilities, doCleanup]\n}\n\nexport function getDirectiveHandler(el, directive) {\n    let noop = () => {}\n\n    let handler = directiveHandlers[directive.type] || noop\n\n    let [utilities, cleanup] = getElementBoundUtilities(el)\n\n    onAttributeRemoved(el, directive.original, cleanup)\n\n    let fullHandler = () => {\n        if (el._x_ignore || el._x_ignoreSelf) return\n\n        handler.inline && handler.inline(el, directive, utilities)\n\n        handler = handler.bind(handler, el, directive, utilities)\n\n        isDeferringHandlers ? directiveHandlerStacks.get(currentHandlerStackKey).push(handler) : handler()\n    }\n\n    fullHandler.runCleanups = cleanup\n\n    return fullHandler\n}\n\nexport let startingWith = (subject, replacement) => ({ name, value }) => {\n    if (name.startsWith(subject)) name = name.replace(subject, replacement)\n\n    return { name, value }\n}\n\nexport let into = i => i\n\nfunction toTransformedAttributes(callback = () => {}) {\n    return ({ name, value }) => {\n        let { name: newName, value: newValue } = attributeTransformers.reduce((carry, transform) => {\n            return transform(carry)\n        }, { name, value })\n\n        if (newName !== name) callback(newName, name)\n\n        return { name: newName, value: newValue }\n    }\n}\n\nlet attributeTransformers = []\n\nexport function mapAttributes(callback) {\n    attributeTransformers.push(callback)\n}\n\nfunction outNonAlpineAttributes({ name }) {\n    return alpineAttributeRegex().test(name)\n}\n\nlet alpineAttributeRegex = () => (new RegExp(`^${prefixAsString}([^:^.]+)\\\\b`))\n\nfunction toParsedDirectives(transformedAttributeMap, originalAttributeOverride) {\n    return ({ name, value }) => {\n        let typeMatch = name.match(alpineAttributeRegex())\n        let valueMatch = name.match(/:([a-zA-Z0-9\\-_:]+)/)\n        let modifiers = name.match(/\\.[^.\\]]+(?=[^\\]]*$)/g) || []\n        let original = originalAttributeOverride || transformedAttributeMap[name] || name\n\n        return {\n            type: typeMatch ? typeMatch[1] : null,\n            value: valueMatch ? valueMatch[1] : null,\n            modifiers: modifiers.map(i => i.replace('.', '')),\n            expression: value,\n            original,\n        }\n    }\n}\n\nconst DEFAULT = 'DEFAULT'\n\nlet directiveOrder = [\n    'ignore',\n    'ref',\n    'data',\n    'id',\n    'anchor',\n    'bind',\n    'init',\n    'for',\n    'model',\n    'modelable',\n    'transition',\n    'show',\n    'if',\n    DEFAULT,\n    'teleport',\n]\n\nfunction byPriority(a, b) {\n    let typeA = directiveOrder.indexOf(a.type) === -1 ? DEFAULT : a.type\n    let typeB = directiveOrder.indexOf(b.type) === -1 ? DEFAULT : b.type\n\n    return directiveOrder.indexOf(typeA) - directiveOrder.indexOf(typeB)\n}\n","\nlet tickStack = []\n\nlet isHolding = false\n\nexport function nextTick(callback = () => {}) {\n  queueMicrotask(() => {\n    isHolding || setTimeout(() => {\n      releaseNextTicks()\n    })\n  })\n\n  return new Promise((res) => {\n    tickStack.push(() => {\n        callback();\n        res();\n    });\n  })\n}\n\nexport function releaseNextTicks() {\n    isHolding = false\n\n    while (tickStack.length) tickStack.shift()()\n}\n\nexport function holdNextTicks() {\n    isHolding = true\n}\n","\nexport function setClasses(el, value) {\n    if (Array.isArray(value)) {\n        return setClassesFromString(el, value.join(' '))\n    } else if (typeof value === 'object' && value !== null) {\n        return setClassesFromObject(el, value)\n    } else if (typeof value === 'function') {\n        return setClasses(el, value())\n    }\n\n    return setClassesFromString(el, value)\n}\n\nfunction setClassesFromString(el, classString) {\n    let split = classString => classString.split(' ').filter(Boolean)\n\n    let missingClasses = classString => classString.split(' ').filter(i => ! el.classList.contains(i)).filter(Boolean)\n\n    let addClassesAndReturnUndo = classes => {\n        el.classList.add(...classes)\n\n        return () => { el.classList.remove(...classes) }\n    }\n\n    // This is to allow short-circuit expressions like: :class=\"show || 'hidden'\" && \"show && 'block'\"\n    classString = (classString === true) ? classString = '' : (classString || '')\n\n    return addClassesAndReturnUndo(missingClasses(classString))\n}\n\nfunction setClassesFromObject(el, classObject) {\n    let split = classString => classString.split(' ').filter(Boolean)\n\n    let forAdd = Object.entries(classObject).flatMap(([classString, bool]) => bool ? split(classString) : false).filter(Boolean)\n    let forRemove = Object.entries(classObject).flatMap(([classString, bool]) => ! bool ? split(classString) : false).filter(Boolean)\n\n    let added = []\n    let removed = []\n\n    forRemove.forEach(i => {\n        if (el.classList.contains(i)) {\n            el.classList.remove(i)\n            removed.push(i)\n        }\n    })\n\n    forAdd.forEach(i => {\n        if (! el.classList.contains(i)) {\n            el.classList.add(i)\n            added.push(i)\n        }\n    })\n\n    return () => {\n        removed.forEach(i => el.classList.add(i))\n        added.forEach(i => el.classList.remove(i))\n    }\n}\n","\nexport function setStyles(el, value) {\n    if (typeof value === 'object' && value !== null) {\n        return setStylesFromObject(el, value)\n    }\n\n    return setStylesFromString(el, value)\n}\n\nfunction setStylesFromObject(el, value) {\n    let previousStyles = {}\n\n    Object.entries(value).forEach(([key, value]) => {\n        previousStyles[key] = el.style[key]\n\n        // When we use javascript object, css properties use the camelCase\n        // syntax but when we use setProperty, we need the css format\n        // so we need to convert camelCase to kebab-case.\n        // In case key is a CSS variable, leave it as it is.\n        if (! key.startsWith('--')) {\n            key = kebabCase(key);\n        }\n\n        el.style.setProperty(key, value)\n    })\n\n    setTimeout(() => {\n        if (el.style.length === 0) {\n            el.removeAttribute('style')\n        }\n    })\n\n    return () => {\n        setStyles(el, previousStyles)\n    }\n}\n\nfunction setStylesFromString(el, value) {\n    let cache = el.getAttribute('style', value)\n\n    el.setAttribute('style', value)\n\n    return () => {\n        el.setAttribute('style', cache || '')\n    }\n}\n\nfunction kebabCase(subject) {\n    return subject.replace(/([a-z])([A-Z])/g, \"$1-$2\").toLowerCase()\n}\n","import { releaseNextTicks, holdNextTicks } from '../nextTick'\nimport { setClasses } from '../utils/classes'\nimport { setStyles } from '../utils/styles'\nimport { directive } from '../directives'\nimport { mutateDom } from '../mutation'\nimport { once } from '../utils/once'\n\ndirective('transition', (el, { value, modifiers, expression }, { evaluate }) => {\n    if (typeof expression === 'function') expression = evaluate(expression)\n    if (expression === false) return\n    if (!expression || typeof expression === 'boolean') {\n        registerTransitionsFromHelper(el, modifiers, value)\n    } else {\n        registerTransitionsFromClassString(el, expression, value)\n    }\n})\n\nfunction registerTransitionsFromClassString(el, classString, stage) {\n    registerTransitionObject(el, setClasses, '')\n\n    let directiveStorageMap = {\n        'enter': (classes) => { el._x_transition.enter.during = classes },\n        'enter-start': (classes) => { el._x_transition.enter.start = classes },\n        'enter-end': (classes) => { el._x_transition.enter.end = classes },\n        'leave': (classes) => { el._x_transition.leave.during = classes },\n        'leave-start': (classes) => { el._x_transition.leave.start = classes },\n        'leave-end': (classes) => { el._x_transition.leave.end = classes },\n    }\n\n    directiveStorageMap[stage](classString)\n}\n\nfunction registerTransitionsFromHelper(el, modifiers, stage) {\n    registerTransitionObject(el, setStyles)\n\n    let doesntSpecify = (! modifiers.includes('in') && ! modifiers.includes('out')) && ! stage\n    let transitioningIn = doesntSpecify || modifiers.includes('in') || ['enter'].includes(stage)\n    let transitioningOut = doesntSpecify || modifiers.includes('out') || ['leave'].includes(stage)\n\n    if (modifiers.includes('in') && ! doesntSpecify) {\n        modifiers = modifiers.filter((i, index) => index < modifiers.indexOf('out'))\n    }\n\n    if (modifiers.includes('out') && ! doesntSpecify) {\n        modifiers = modifiers.filter((i, index) => index > modifiers.indexOf('out'))\n    }\n\n    let wantsAll = ! modifiers.includes('opacity') && ! modifiers.includes('scale')\n    let wantsOpacity = wantsAll || modifiers.includes('opacity')\n    let wantsScale = wantsAll || modifiers.includes('scale')\n    let opacityValue = wantsOpacity ? 0 : 1\n    let scaleValue = wantsScale ? modifierValue(modifiers, 'scale', 95) / 100 : 1\n    let delay = modifierValue(modifiers, 'delay', 0) / 1000\n    let origin = modifierValue(modifiers, 'origin', 'center')\n    let property = 'opacity, transform'\n    let durationIn = modifierValue(modifiers, 'duration', 150) / 1000\n    let durationOut = modifierValue(modifiers, 'duration', 75) / 1000\n    let easing = `cubic-bezier(0.4, 0.0, 0.2, 1)`\n\n    if (transitioningIn) {\n        el._x_transition.enter.during = {\n            transformOrigin: origin,\n            transitionDelay: `${delay}s`,\n            transitionProperty: property,\n            transitionDuration: `${durationIn}s`,\n            transitionTimingFunction: easing,\n        }\n\n        el._x_transition.enter.start = {\n            opacity: opacityValue,\n            transform: `scale(${scaleValue})`,\n        }\n\n        el._x_transition.enter.end = {\n            opacity: 1,\n            transform: `scale(1)`,\n        }\n    }\n\n    if (transitioningOut) {\n        el._x_transition.leave.during = {\n            transformOrigin: origin,\n            transitionDelay: `${delay}s`,\n            transitionProperty: property,\n            transitionDuration: `${durationOut}s`,\n            transitionTimingFunction: easing,\n        }\n\n        el._x_transition.leave.start = {\n            opacity: 1,\n            transform: `scale(1)`,\n        }\n\n        el._x_transition.leave.end = {\n            opacity: opacityValue,\n            transform: `scale(${scaleValue})`,\n        }\n    }\n}\n\nfunction registerTransitionObject(el, setFunction, defaultValue = {}) {\n    if (! el._x_transition) el._x_transition = {\n        enter: { during: defaultValue, start: defaultValue, end: defaultValue },\n\n        leave: { during: defaultValue, start: defaultValue, end: defaultValue },\n\n        in(before = () => {}, after = () => {}) {\n            transition(el, setFunction, {\n                during: this.enter.during,\n                start: this.enter.start,\n                end: this.enter.end,\n            }, before, after)\n        },\n\n        out(before = () => {}, after = () => {}) {\n            transition(el, setFunction, {\n                during: this.leave.during,\n                start: this.leave.start,\n                end: this.leave.end,\n            }, before, after)\n        },\n    }\n}\n\nwindow.Element.prototype._x_toggleAndCascadeWithTransitions = function (el, value, show, hide) {\n    // We are running this function after one tick to prevent\n    // a race condition from happening where elements that have a\n    // @click.away always view themselves as shown on the page.\n    // If the tab is active, we prioritise requestAnimationFrame which plays\n    // nicely with nested animations otherwise we use setTimeout to make sure\n    // it keeps running in background. setTimeout has a lower priority in the\n    // event loop so it would skip nested transitions but when the tab is\n    // hidden, it's not relevant.\n    const nextTick = document.visibilityState === 'visible' ? requestAnimationFrame : setTimeout;\n    let clickAwayCompatibleShow = () => nextTick(show);\n\n    if (value) {\n        if (el._x_transition && (el._x_transition.enter || el._x_transition.leave)) {\n            // This fixes a bug where if you are only transitioning OUT and you are also using @click.outside\n            // the element when shown immediately starts transitioning out. There is a test in the manual\n            // transition test file for this: /tests/cypress/manual-transition-test.html\n            (el._x_transition.enter && (Object.entries(el._x_transition.enter.during).length || Object.entries(el._x_transition.enter.start).length || Object.entries(el._x_transition.enter.end).length))\n                ? el._x_transition.in(show)\n                : clickAwayCompatibleShow()\n        } else {\n            el._x_transition\n                ? el._x_transition.in(show)\n                : clickAwayCompatibleShow()\n        }\n\n        return\n    }\n\n    // Livewire depends on el._x_hidePromise.\n    el._x_hidePromise = el._x_transition\n        ? new Promise((resolve, reject) => {\n            el._x_transition.out(() => {}, () => resolve(hide))\n\n            el._x_transitioning && el._x_transitioning.beforeCancel(() => reject({ isFromCancelledTransition: true }))\n        })\n        : Promise.resolve(hide)\n\n    queueMicrotask(() => {\n        let closest = closestHide(el)\n\n        if (closest) {\n            if (! closest._x_hideChildren) closest._x_hideChildren = []\n\n            closest._x_hideChildren.push(el)\n        } else {\n            nextTick(() => {\n                let hideAfterChildren = el => {\n                    let carry = Promise.all([\n                        el._x_hidePromise,\n                        ...(el._x_hideChildren || []).map(hideAfterChildren),\n                    ]).then(([i]) => i())\n\n                    delete el._x_hidePromise\n                    delete el._x_hideChildren\n\n                    return carry\n                }\n\n                hideAfterChildren(el).catch((e) => {\n                    if (! e.isFromCancelledTransition) throw e\n                })\n            })\n        }\n    })\n}\n\nfunction closestHide(el) {\n    let parent = el.parentNode\n\n    if (! parent) return\n\n    return parent._x_hidePromise ? parent : closestHide(parent)\n}\n\nexport function transition(el, setFunction, { during, start, end } = {}, before = () => {}, after = () => {}) {\n    if (el._x_transitioning) el._x_transitioning.cancel()\n\n    if (Object.keys(during).length === 0 && Object.keys(start).length === 0 && Object.keys(end).length === 0) {\n        // Execute right away if there is no transition.\n        before(); after()\n        return\n    }\n\n    let undoStart, undoDuring, undoEnd\n\n    performTransition(el, {\n        start() {\n            undoStart = setFunction(el, start)\n        },\n        during() {\n            undoDuring = setFunction(el, during)\n        },\n        before,\n        end() {\n            undoStart()\n\n            undoEnd = setFunction(el, end)\n        },\n        after,\n        cleanup() {\n            undoDuring()\n            undoEnd()\n        },\n    })\n}\n\nexport function performTransition(el, stages) {\n    // All transitions need to be truly \"cancellable\". Meaning we need to\n    // account for interruptions at ALL stages of the transitions and\n    // immediately run the rest of the transition.\n    let interrupted, reachedBefore, reachedEnd\n\n    let finish = once(() => {\n        mutateDom(() => {\n            interrupted = true\n\n            if (! reachedBefore) stages.before()\n\n            if (! reachedEnd) {\n                stages.end()\n\n                releaseNextTicks()\n            }\n\n            stages.after()\n\n            // Adding an \"isConnected\" check, in case the callback removed the element from the DOM.\n            if (el.isConnected) stages.cleanup()\n\n            delete el._x_transitioning\n        })\n    })\n\n    el._x_transitioning = {\n        beforeCancels: [],\n        beforeCancel(callback) { this.beforeCancels.push(callback) },\n        cancel: once(function () { while (this.beforeCancels.length) { this.beforeCancels.shift()() }; finish(); }),\n        finish,\n    }\n\n    mutateDom(() => {\n        stages.start()\n        stages.during()\n    })\n\n    holdNextTicks()\n\n    requestAnimationFrame(() => {\n        if (interrupted) return\n\n        // Note: Safari's transitionDuration property will list out comma separated transition durations\n        // for every single transition property. Let's grab the first one and call it a day.\n        let duration = Number(getComputedStyle(el).transitionDuration.replace(/,.*/, '').replace('s', '')) * 1000\n        let delay = Number(getComputedStyle(el).transitionDelay.replace(/,.*/, '').replace('s', '')) * 1000\n\n        if (duration === 0) duration = Number(getComputedStyle(el).animationDuration.replace('s', '')) * 1000\n\n        mutateDom(() => {\n            stages.before()\n        })\n\n        reachedBefore = true\n\n        requestAnimationFrame(() => {\n            if (interrupted) return\n\n            mutateDom(() => {\n                stages.end()\n            })\n\n            releaseNextTicks()\n\n            setTimeout(el._x_transitioning.finish, duration + delay)\n\n            reachedEnd = true\n        })\n    })\n}\n\nexport function modifierValue(modifiers, key, fallback) {\n    // If the modifier isn't present, use the default.\n    if (modifiers.indexOf(key) === -1) return fallback\n\n    // If it IS present, grab the value after it: x-show.transition.duration.500ms\n    const rawValue = modifiers[modifiers.indexOf(key) + 1]\n\n    if (! rawValue) return fallback\n\n    if (key === 'scale') {\n        // Check if the very next value is NOT a number and return the fallback.\n        // If x-show.transition.scale, we'll use the default scale value.\n        // That is how a user opts out of the opacity transition.\n        if (isNaN(rawValue)) return fallback\n    }\n\n    if (key === 'duration' || key === 'delay') {\n        // Support x-transition.duration.500ms && duration.500\n        let match = rawValue.match(/([0-9]+)ms/)\n        if (match) return match[1]\n    }\n\n    if (key === 'origin') {\n        // Support chaining origin directions: x-show.transition.top.right\n        if (['top', 'right', 'left', 'center', 'bottom'].includes(modifiers[modifiers.indexOf(key) + 2])) {\n            return [rawValue, modifiers[modifiers.indexOf(key) + 2]].join(' ')\n        }\n    }\n\n    return rawValue\n}\n","import { effect, release, overrideEffect } from \"./reactivity\"\nimport { initTree, isRoot } from \"./lifecycle\"\nimport { walk } from \"./utils/walk\"\n\nexport let isCloning = false\n\nexport function skipDuringClone(callback, fallback = () => {}) {\n    return (...args) => isCloning ? fallback(...args) : callback(...args)\n}\n\nexport function onlyDuringClone(callback) {\n    return (...args) => isCloning && callback(...args)\n}\n\nlet interceptors = []\n\nexport function interceptClone(callback) {\n    interceptors.push(callback)\n}\n\nexport function cloneNode(from, to)\n{\n    interceptors.forEach(i => i(from, to))\n\n    isCloning = true\n\n    // We don't need reactive effects in the new tree.\n    // Cloning is just used to seed new server HTML with\n    // Alpine before \"morphing\" it onto live Alpine...\n    dontRegisterReactiveSideEffects(() => {\n        initTree(to, (el, callback) => {\n            // We're hijacking the \"walker\" so that we\n            // only initialize the element we're cloning...\n            callback(el, () => {})\n        })\n    })\n\n    isCloning = false\n}\n\nexport let isCloningLegacy = false\n\n/** deprecated */\nexport function clone(oldEl, newEl) {\n    if (! newEl._x_dataStack) newEl._x_dataStack = oldEl._x_dataStack\n\n    isCloning = true\n    isCloningLegacy = true\n\n    dontRegisterReactiveSideEffects(() => {\n        cloneTree(newEl)\n    })\n\n    isCloning = false\n    isCloningLegacy = false\n}\n\n/** deprecated */\nexport function cloneTree(el) {\n    let hasRunThroughFirstEl = false\n\n    let shallowWalker = (el, callback) => {\n        walk(el, (el, skip) => {\n            if (hasRunThroughFirstEl && isRoot(el)) return skip()\n\n            hasRunThroughFirstEl = true\n\n            callback(el, skip)\n        })\n    }\n\n    initTree(el, shallowWalker)\n}\n\nfunction dontRegisterReactiveSideEffects(callback) {\n    let cache = effect\n\n    overrideEffect((callback, el) => {\n        let storedEffect = cache(callback)\n\n        release(storedEffect)\n\n        return () => {}\n    })\n\n    callback()\n\n    overrideEffect(cache)\n}\n","// Warning: The concept of \"interceptors\" in Alpine is not public API and is subject to change\n// without tagging a major release.\n\nexport function initInterceptors(data) {\n    let isObject = val => typeof val === 'object' && !Array.isArray(val) && val !== null\n\n    let recurse = (obj, basePath = '') => {\n        Object.entries(Object.getOwnPropertyDescriptors(obj)).forEach(([key, { value, enumerable }]) => {\n            // Skip getters.\n            if (enumerable === false || value === undefined) return\n\n            let path = basePath === '' ? key : `${basePath}.${key}`\n\n            if (typeof value === 'object' && value !== null && value._x_interceptor) {\n                obj[key] = value.initialize(data, path, key)\n            } else {\n                if (isObject(value) && value !== obj && ! (value instanceof Element)) {\n                    recurse(value, path)\n                }\n            }\n        })\n    }\n\n    return recurse(data)\n}\n\nexport function interceptor(callback, mutateObj = () => {}) {\n    let obj = {\n        initialValue: undefined,\n\n        _x_interceptor: true,\n\n        initialize(data, path, key) {\n            return callback(this.initialValue, () => get(data, path), (value) => set(data, path, value), path, key)\n        }\n    }\n\n    mutateObj(obj)\n\n    return initialValue => {\n        if (typeof initialValue === 'object' && initialValue !== null && initialValue._x_interceptor) {\n            // Support nesting interceptors.\n            let initialize = obj.initialize.bind(obj)\n\n            obj.initialize = (data, path, key) => {\n                let innerValue = initialValue.initialize(data, path, key)\n\n                obj.initialValue = innerValue\n\n                return initialize(data, path, key)\n            }\n        } else {\n            obj.initialValue = initialValue\n        }\n\n        return obj\n    }\n}\n\nfunction get(obj, path) {\n    return path.split('.').reduce((carry, segment) => carry[segment], obj)\n}\n\nfunction set(obj, path, value) {\n    if (typeof path === 'string') path = path.split('.')\n\n    if (path.length === 1) obj[path[0]] = value;\n       else if (path.length === 0) throw error;\n    else {\n       if (obj[path[0]])\n          return set(obj[path[0]], path.slice(1), value);\n       else {\n          obj[path[0]] = {};\n          return set(obj[path[0]], path.slice(1), value);\n       }\n    }\n}\n","import { dontAutoEvaluateFunctions, evaluate } from '../evaluator'\nimport { reactive } from '../reactivity'\nimport { setClasses } from './classes'\nimport { setStyles } from './styles'\n\nexport default function bind(el, name, value, modifiers = []) {\n    // Register bound data as pure observable data for other APIs to use.\n    if (! el._x_bindings) el._x_bindings = reactive({})\n\n    el._x_bindings[name] = value\n\n    name = modifiers.includes('camel') ? camelCase(name) : name\n\n    switch (name) {\n        case 'value':\n            bindInputValue(el, value)\n            break;\n\n        case 'style':\n            bindStyles(el, value)\n            break;\n\n        case 'class':\n            bindClasses(el, value)\n            break;\n\n        // 'selected' and 'checked' are special attributes that aren't necessarily\n        // synced with their corresponding properties when updated, so both the\n        // attribute and property need to be updated when bound.\n        case 'selected':\n        case 'checked':\n            bindAttributeAndProperty(el, name, value)\n            break;\n\n        default:\n            bindAttribute(el, name, value)\n            break;\n    }\n}\n\nfunction bindInputValue(el, value) {\n    if (el.type === 'radio') {\n        // Set radio value from x-bind:value, if no \"value\" attribute exists.\n        // If there are any initial state values, radio will have a correct\n        // \"checked\" value since x-bind:value is processed before x-model.\n        if (el.attributes.value === undefined) {\n            el.value = value\n        }\n\n        // @todo: yuck\n        if (window.fromModel) {\n            if (typeof value === 'boolean') {\n                el.checked = safeParseBoolean(el.value) === value\n            } else {\n                el.checked = checkedAttrLooseCompare(el.value, value)\n            }\n        }\n    } else if (el.type === 'checkbox') {\n        // If we are explicitly binding a string to the :value, set the string,\n        // If the value is a boolean/array/number/null/undefined, leave it alone, it will be set to \"on\"\n        // automatically.\n        if (Number.isInteger(value)) {\n            el.value = value\n        } else if (! Array.isArray(value) && typeof value !== 'boolean' && ! [null, undefined].includes(value)) {\n            el.value = String(value)\n        } else {\n            if (Array.isArray(value)) {\n                el.checked = value.some(val => checkedAttrLooseCompare(val, el.value))\n            } else {\n                el.checked = !!value\n            }\n        }\n    } else if (el.tagName === 'SELECT') {\n        updateSelect(el, value)\n    } else {\n        if (el.value === value) return\n\n        el.value = value === undefined ? '' : value\n    }\n}\n\nfunction bindClasses(el, value) {\n    if (el._x_undoAddedClasses) el._x_undoAddedClasses()\n\n    el._x_undoAddedClasses = setClasses(el, value)\n}\n\nfunction bindStyles(el, value) {\n    if (el._x_undoAddedStyles) el._x_undoAddedStyles()\n\n    el._x_undoAddedStyles = setStyles(el, value)\n}\n\nfunction bindAttributeAndProperty(el, name, value) {\n    bindAttribute(el, name, value)\n    setPropertyIfChanged(el, name, value)\n}\n\nfunction bindAttribute(el, name, value) {\n    if ([null, undefined, false].includes(value) && attributeShouldntBePreservedIfFalsy(name)) {\n        el.removeAttribute(name)\n    } else {\n        if (isBooleanAttr(name)) value = name\n\n        setIfChanged(el, name, value)\n    }\n}\n\nfunction setIfChanged(el, attrName, value) {\n    if (el.getAttribute(attrName) != value) {\n        el.setAttribute(attrName, value)\n    }\n}\n\nfunction setPropertyIfChanged(el, propName, value) {\n    if (el[propName] !== value) {\n        el[propName] = value\n    }\n}\n\nfunction updateSelect(el, value) {\n    const arrayWrappedValue = [].concat(value).map(value => { return value + '' })\n\n    Array.from(el.options).forEach(option => {\n        option.selected = arrayWrappedValue.includes(option.value)\n    })\n}\n\nfunction camelCase(subject) {\n    return subject.toLowerCase().replace(/-(\\w)/g, (match, char) => char.toUpperCase())\n}\n\nfunction checkedAttrLooseCompare(valueA, valueB) {\n    return valueA == valueB\n}\n\nexport function safeParseBoolean(rawValue) {\n    if ([1, '1', 'true', 'on', 'yes', true].includes(rawValue)) {\n        return true\n    }\n\n    if ([0, '0', 'false', 'off', 'no', false].includes(rawValue)) {\n        return false\n    }\n\n    return rawValue ? Boolean(rawValue) : null\n}\n\nfunction isBooleanAttr(attrName) {\n    // As per HTML spec table https://html.spec.whatwg.org/multipage/indices.html#attributes-3:boolean-attribute\n    // Array roughly ordered by estimated usage\n    const booleanAttributes = [\n        'disabled','checked','required','readonly','hidden','open', 'selected',\n        'autofocus', 'itemscope', 'multiple', 'novalidate','allowfullscreen',\n        'allowpaymentrequest', 'formnovalidate', 'autoplay', 'controls', 'loop',\n        'muted', 'playsinline', 'default', 'ismap', 'reversed', 'async', 'defer',\n        'nomodule'\n    ]\n\n    return booleanAttributes.includes(attrName)\n}\n\nfunction attributeShouldntBePreservedIfFalsy(name) {\n    return ! ['aria-pressed', 'aria-checked', 'aria-expanded', 'aria-selected'].includes(name)\n}\n\nexport function getBinding(el, name, fallback) {\n    // First let's get it out of Alpine bound data.\n    if (el._x_bindings && el._x_bindings[name] !== undefined) return el._x_bindings[name]\n\n    return getAttributeBinding(el, name, fallback)\n}\n\nexport function extractProp(el, name, fallback, extract = true) {\n    // First let's get it out of Alpine bound data.\n    if (el._x_bindings && el._x_bindings[name] !== undefined) return el._x_bindings[name]\n\n    if (el._x_inlineBindings && el._x_inlineBindings[name] !== undefined) {\n        let binding = el._x_inlineBindings[name]\n\n        binding.extract = extract\n\n        return dontAutoEvaluateFunctions(() => {\n            return evaluate(el, binding.expression)\n        })\n    }\n\n    return getAttributeBinding(el, name, fallback)\n}\n\nfunction getAttributeBinding(el, name, fallback) {\n    // If not, we'll return the literal attribute.\n    let attr = el.getAttribute(name)\n\n    // Nothing bound:\n    if (attr === null) return typeof fallback === 'function' ? fallback() : fallback\n\n    // The case of a custom attribute with no value. Ex: <div manual>\n    if (attr === '') return true\n\n    if (isBooleanAttr(name)) {\n        return !! [name, 'true'].includes(attr)\n    }\n\n    return attr\n}\n","import { effect, release } from './reactivity'\n\nexport function entangle({ get: outerGet, set: outerSet }, { get: innerGet, set: innerSet }) {\n    let firstRun = true\n    let outerHash\n    let innerHash\n\n    let reference = effect(() => {\n        let outer = outerGet()\n        let inner = innerGet()\n\n        if (firstRun) {\n            innerSet(cloneIfObject(outer))\n            firstRun = false\n        } else {\n            let outerHashLatest = JSON.stringify(outer)\n            let innerHashLatest = JSON.stringify(inner)\n\n            if (outerHashLatest !== outerHash) { // If outer changed...\n                innerSet(cloneIfObject(outer))\n            } else if (outerHashLatest !== innerHashLatest) { // If inner changed...\n                outerSet(cloneIfObject(inner))\n            } else { // If nothing changed...\n                // Prevent an infinite loop...\n            }\n        }\n\n        outerHash = JSON.stringify(outerGet())\n        innerHash = JSON.stringify(innerGet())\n    })\n\n    return () => {\n        release(reference)\n    }\n}\n\nfunction cloneIfObject(value) {\n    return typeof value === 'object'\n        ? JSON.parse(JSON.stringify(value))\n        : value\n}\n","import Alpine from \"./alpine\";\n\nexport function plugin(callback) {\n    let callbacks = Array.isArray(callback) ? callback : [callback]\n\n    callbacks.forEach(i => i(Alpine))\n}\n","import { initInterceptors } from \"./interceptor\";\nimport { reactive } from \"./reactivity\"\n\nlet stores = {}\nlet isReactive = false\n\nexport function store(name, value) {\n    if (! isReactive) { stores = reactive(stores); isReactive = true; }\n\n    if (value === undefined) {\n        return stores[name]\n    }\n\n    stores[name] = value\n\n    if (typeof value === 'object' && value !== null && value.hasOwnProperty('init') && typeof value.init === 'function') {\n        stores[name].init()\n    }\n\n    initInterceptors(stores[name])\n}\n\nexport function getStores() { return stores }\n","import { attributesOnly, directives } from \"./directives\"\n\nlet binds = {}\n\nexport function bind(name, bindings) {\n    let getBindings = typeof bindings !== 'function' ? () => bindings : bindings\n\n    if (name instanceof Element) {\n        return applyBindingsObject(name, getBindings())\n    } else {\n        binds[name] = getBindings\n    }\n\n    return () => {} // Null cleanup...\n}\n\nexport function injectBindingProviders(obj) {\n    Object.entries(binds).forEach(([name, callback]) => {\n        Object.defineProperty(obj, name, {\n            get() {\n                return (...args) => {\n                    return callback(...args)\n                }\n            }\n        })\n    })\n\n    return obj\n}\n\nexport function addVirtualBindings(el, bindings) {\n    let getBindings = typeof bindings !== 'function' ? () => bindings : bindings\n\n    el._x_virtualDirectives = getBindings()\n}\n\nexport function applyBindingsObject(el, obj, original) {\n    let cleanupRunners = []\n\n    while (cleanupRunners.length) cleanupRunners.pop()()\n\n    let attributes = Object.entries(obj).map(([name, value]) => ({ name, value }))\n\n    let staticAttributes = attributesOnly(attributes)\n\n    // Handle binding normal HTML attributes (non-Alpine directives).\n    attributes = attributes.map(attribute => {\n        if (staticAttributes.find(attr => attr.name === attribute.name)) {\n            return {\n                name: `x-bind:${attribute.name}`,\n                value: `\"${attribute.value}\"`,\n            }\n        }\n\n        return attribute\n    })\n\n    directives(el, attributes, original).map(handle => {\n        cleanupRunners.push(handle.runCleanups)\n\n        handle()\n    })\n\n    return () => {\n        while (cleanupRunners.length) cleanupRunners.pop()()\n    }\n}\n","\nlet datas = {}\n\nexport function data(name, callback) {\n    datas[name] = callback\n}\n\nexport function injectDataProviders(obj, context) {\n    Object.entries(datas).forEach(([name, callback]) => {\n        Object.defineProperty(obj, name, {\n            get() {\n                return (...args) => {\n                    return callback.bind(context)(...args)\n                }\n            },\n\n            enumerable: false,\n        })\n    })\n\n    return obj\n}\n","import { setReactivityEngine, disableEffectScheduling, reactive, effect, release, raw, watch } from './reactivity'\nimport { mapAttributes, directive, setPrefix as prefix, prefix as prefixed } from './directives'\nimport { start, addRootSelector, addInitSelector, closestRoot, findClosest, initTree, destroyTree, interceptInit } from './lifecycle'\nimport { onElRemoved, onAttributeRemoved, onAttributesAdded, mutateDom, deferMutations, flushAndStopDeferringMutations, startObservingMutations, stopObservingMutations } from './mutation'\nimport { mergeProxies, closestDataStack, addScopeToNode, scope as $data } from './scope'\nimport { setEvaluator, evaluate, evaluateLater, dontAutoEvaluateFunctions } from './evaluator'\nimport { transition } from './directives/x-transition'\nimport { clone, cloneNode, skipDuringClone, onlyDuringClone, interceptClone } from './clone'\nimport { interceptor } from './interceptor'\nimport { getBinding as bound, extractProp } from './utils/bind'\nimport { debounce } from './utils/debounce'\nimport { throttle } from './utils/throttle'\nimport { setStyles } from './utils/styles'\nimport { entangle } from './entangle'\nimport { nextTick } from './nextTick'\nimport { walk } from './utils/walk'\nimport { plugin } from './plugin'\nimport { magic } from './magics'\nimport { store } from './store'\nimport { bind } from './binds'\nimport { data } from './datas'\n\nlet Alpine = {\n    get reactive() { return reactive },\n    get release() { return release },\n    get effect() { return effect },\n    get raw() { return raw },\n    version: ALPINE_VERSION,\n    flushAndStopDeferringMutations,\n    dontAutoEvaluateFunctions,\n    disableEffectScheduling,\n    startObservingMutations,\n    stopObservingMutations,\n    setReactivityEngine,\n    onAttributeRemoved,\n    onAttributesAdded,\n    closestDataStack,\n    skipDuringClone,\n    onlyDuringClone,\n    addRootSelector,\n    addInitSelector,\n    interceptClone,\n    addScopeToNode,\n    deferMutations,\n    mapAttributes,\n    evaluateLater,\n    interceptInit,\n    setEvaluator,\n    mergeProxies,\n    extractProp,\n    findClosest,\n    onElRemoved,\n    closestRoot,\n    destroyTree,\n    interceptor, // INTERNAL: not public API and is subject to change without major release.\n    transition, // INTERNAL\n    setStyles, // INTERNAL\n    mutateDom,\n    directive,\n    entangle,\n    throttle,\n    debounce,\n    evaluate,\n    initTree,\n    nextTick,\n    prefixed,\n    prefix,\n    plugin,\n    magic,\n    store,\n    start,\n    clone, // INTERNAL\n    cloneNode, // INTERNAL\n    bound,\n    $data,\n    watch,\n    walk,\n    data,\n    bind,\n}\n\nexport default Alpine\n","import Alpine from './alpine'\nimport { getElementBoundUtilities } from './directives'\nimport { interceptor } from './interceptor'\nimport { onElRemoved } from './mutation'\n\nlet magics = {}\n\nexport function magic(name, callback) {\n    magics[name] = callback\n}\n\nexport function injectMagics(obj, el) {\n    Object.entries(magics).forEach(([name, callback]) => {\n        let memoizedUtilities = null;\n        function getUtilities() {\n            if (memoizedUtilities) {\n                return memoizedUtilities;\n            } else {\n                let [utilities, cleanup] = getElementBoundUtilities(el)\n                \n                memoizedUtilities = {interceptor, ...utilities}\n                \n                onElRemoved(el, cleanup)\n                return memoizedUtilities;\n            }\n        }\n        \n        Object.defineProperty(obj, `$${name}`, {\n            get() {\n                return callback(el, getUtilities());\n            },\n            enumerable: false,\n        })\n    })\n\n    return obj\n}\n"],"names":["warn","message","args","console","flushPending","flushing","queue","lastFlushedIndex","scheduler","callback","queueJob","job","includes","push","queueFlush","dequeueJob","index","indexOf","splice","queueMicrotask","flushJobs","i","length","reactive","effect","release","raw","shouldSchedule","disableEffectScheduling","setReactivityEngine","engine","task","overrideEffect","override","elementBoundEffect","el","cleanup","wrappedEffect","effectReference","_x_effects","Set","_x_runEffects","forEach","add","undefined","delete","watch","getter","firstTime","oldValue","value","JSON","stringify","dispatch","name","detail","dispatchEvent","CustomEvent","bubbles","composed","cancelable","walk","ShadowRoot","Array","from","children","skip","node","firstElementChild","nextElementSibling","started","start","document","body","startObservingMutations","onElAdded","initTree","onElRemoved","destroyTree","onAttributesAdded","attrs","directives","handle","outNestedComponents","closestRoot","parentElement","querySelectorAll","allSelectors","join","filter","rootSelectorCallbacks","initSelectorCallbacks","rootSelectors","map","fn","concat","addRootSelector","selectorCallback","addInitSelector","includeInitSelectors","findClosest","element","selectors","some","selector","matches","_x_teleportBack","isRoot","initInterceptors","interceptInit","walker","intercept","deferHandlingDirectives","attributes","_x_ignore","root","cleanupAttributes","cleanupElement","onAttributeAddeds","onElRemoveds","onElAddeds","_x_cleanups","onAttributeRemoved","_x_attributeCleanups","names","Object","entries","pop","observer","MutationObserver","onMutate","currentlyObserving","observe","subtree","childList","attributeOldValue","stopObservingMutations","flushObserver","disconnect","queuedMutations","records","takeRecords","queueLengthWhenTriggered","shift","mutateDom","result","isCollecting","deferredMutations","deferMutations","flushAndStopDeferringMutations","mutations","addedNodes","removedNodes","addedAttributes","Map","removedAttributes","target","_x_ignoreMutationObserver","type","nodeType","attributeName","has","set","get","getAttribute","remove","hasAttribute","_x_ignoreSelf","isConnected","shouldAutoEvaluateFunctions","dontAutoEvaluateFunctions","cache","evaluate","expression","extras","evaluateLater","theEvaluatorFunction","normalEvaluator","setEvaluator","newEvaluator","overriddenMagics","injectMagics","dataStack","closestDataStack","evaluator","generateEvaluatorFromFunction","generateEvaluatorFromString","tryCatch","bind","func","receiver","scope","params","apply","mergeProxies","runIfTypeOfFunction","evaluatorMemo","generateFunctionFromString","AsyncFunction","getPrototypeOf","async","constructor","rightSideSafeExpression","test","trim","safeAsyncFunction","defineProperty","error","handleError","Promise","resolve","finished","completeScope","promise","catch","then","finally","prefixAsString","prefix","subject","setPrefix","newPrefix","directiveHandlers","directive","before","String","pos","directiveOrder","originalAttributeOverride","_x_virtualDirectives","vAttributes","staticAttributes","attributesOnly","attribute","find","attr","transformedAttributeMap","toTransformedAttributes","newName","oldName","outNonAlpineAttributes","toParsedDirectives","sort","byPriority","getDirectiveHandler","isDeferringHandlers","directiveHandlerStacks","currentHandlerStackKey","Symbol","key","flushHandlers","stopDeferring","getElementBoundUtilities","cleanups","cleanupEffect","utilities","Alpine","doCleanup","noop","handler","original","fullHandler","inline","runCleanups","startingWith","replacement","startsWith","replace","into","newValue","attributeTransformers","reduce","carry","transform","mapAttributes","alpineAttributeRegex","RegExp","typeMatch","match","valueMatch","modifiers","DEFAULT","a","b","typeA","typeB","tickStack","isHolding","nextTick","setTimeout","releaseNextTicks","res","holdNextTicks","setClasses","isArray","setClassesFromString","setClassesFromObject","classString","missingClasses","split","classList","contains","Boolean","addClassesAndReturnUndo","classes","classObject","forAdd","flatMap","bool","forRemove","added","removed","setStyles","setStylesFromObject","setStylesFromString","previousStyles","style","kebabCase","setProperty","removeAttribute","setAttribute","toLowerCase","registerTransitionsFromClassString","registerTransitionsFromHelper","stage","registerTransitionObject","directiveStorageMap","enter","_x_transition","during","end","leave","doesntSpecify","transitioningIn","transitioningOut","wantsAll","wantsOpacity","wantsScale","opacityValue","scaleValue","modifierValue","delay","origin","property","durationIn","durationOut","easing","transformOrigin","transitionDelay","transitionProperty","transitionDuration","transitionTimingFunction","opacity","setFunction","defaultValue","after","transition","this","out","window","Element","prototype","_x_toggleAndCascadeWithTransitions","show","hide","visibilityState","requestAnimationFrame","clickAwayCompatibleShow","in","_x_hidePromise","reject","_x_transitioning","beforeCancel","isFromCancelledTransition","closest","closestHide","_x_hideChildren","hideAfterChildren","all","e","parent","parentNode","cancel","keys","undoStart","undoDuring","undoEnd","performTransition","stages","interrupted","reachedBefore","reachedEnd","finish","once","beforeCancels","duration","Number","getComputedStyle","animationDuration","fallback","rawValue","isNaN","isCloning","skipDuringClone","onlyDuringClone","interceptors","interceptClone","cloneNode","to","dontRegisterReactiveSideEffects","isCloningLegacy","clone","oldEl","newEl","_x_dataStack","cloneTree","hasRunThroughFirstEl","shallowWalker","storedEffect","data","isObject","val","recurse","obj","basePath","getOwnPropertyDescriptors","enumerable","path","_x_interceptor","initialize","interceptor","mutateObj","initialValue","innerValue","segment","slice","_x_bindings","camelCase","bindInputValue","bindStyles","bindClasses","bindAttributeAndProperty","bindAttribute","fromModel","checked","safeParseBoolean","checkedAttrLooseCompare","isInteger","tagName","updateSelect","_x_undoAddedClasses","_x_undoAddedStyles","setPropertyIfChanged","attributeShouldntBePreservedIfFalsy","isBooleanAttr","setIfChanged","attrName","propName","arrayWrappedValue","options","option","selected","char","toUpperCase","valueA","valueB","booleanAttributes","getBinding","getAttributeBinding","extractProp","extract","_x_inlineBindings","binding","entangle","outerGet","outerSet","innerGet","innerSet","firstRun","outerHash","innerHash","reference","outer","inner","cloneIfObject","outerHashLatest","innerHashLatest","parse","plugin","callbacks","stores","isReactive","store","hasOwnProperty","init","getStores","binds","bindings","getBindings","applyBindingsObject","injectBindingProviders","cleanupRunners","datas","injectDataProviders","context","version","ALPINE_VERSION","addScopeToNode","throttle","debounce","prefixed","magic","bound","$data","Alpine$1","magics","memoizedUtilities","getUtilities"],"mappings":"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"}